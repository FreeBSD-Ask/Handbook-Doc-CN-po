# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2022-03-11 21:42+0800\n"
"PO-Revision-Date: 2022-04-05 17:01+0800\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#. type: YAML Front Matter: description
#: content/zh-cn/books/handbook/geom/_index.adoc:1
#, no-wrap
msgid "In FreeBSD, the GEOM framework permits access and control to classes, such as Master Boot Records and BSD labels, through the use of providers, or the disk devices in /dev."
msgstr "在 FreeBSD 中，GEOM 框架允许通过使用提供者或 /dev 中的磁盘设备来访问和控制类，如主启动记录和 BSD 标签。"

#. type: YAML Front Matter: part
#: content/zh-cn/books/handbook/geom/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "第三部分 系统管理"

#. type: YAML Front Matter: title
#: content/zh-cn/books/handbook/geom/_index.adoc:1
#, no-wrap
msgid "Chapter 19. GEOM: Modular Disk Transformation Framework"
msgstr "GEOM: 模块化磁盘转换框架"

#. type: Title =
#: content/zh-cn/books/handbook/geom/_index.adoc:14
#, no-wrap
msgid "GEOM: Modular Disk Transformation Framework"
msgstr "GEOM: 模块化磁盘转换框架"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "概述"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:56
msgid ""
"In FreeBSD, the GEOM framework permits access and control to classes, such as Master Boot Records and BSD labels, through the use of providers, or the disk devices in [."
"filename]#/dev#.  By supporting various software RAID configurations, GEOM transparently provides access to the operating system and operating system utilities."
msgstr ""
"在 FreeBSD 中，GEOM 框架允许通过使用提供者或 [.filename]#/dev# 中的磁盘设备来访问和控制类，如主启动记录和 BSD 标签。通过支持各种软件 RAID 配置，GEOM 透明地提供对操作系统和操作系"
"统工具的访问。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:60
msgid ""
"This chapter covers the use of disks under the GEOM framework in FreeBSD.  This includes the major RAID control utilities which use the framework for configuration.  This "
"chapter is not a definitive guide to RAID configurations and only GEOM-supported RAID classifications are discussed."
msgstr ""
"本章介绍了在 FreeBSD 的 GEOM 框架下使用磁盘的情况。这包括主要的 RAID 控制工具，这些工具使用该框架进行配置。这一章并不是 RAID 配置的权威指南，只讨论了 GEOM 支持的 RAID 分类。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:62
msgid "After reading this chapter, you will know:"
msgstr "读完本章后，你会知道："

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:64
msgid "What type of RAID support is available through GEOM."
msgstr "GEOM 支持什么类型的 RAID。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:65
msgid "How to use the base utilities to configure, maintain, and manipulate the various RAID levels."
msgstr "如何使用基本的实用程序来配置、维护和操作各种 RAID 级别。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:66
msgid "How to mirror, stripe, encrypt, and remotely connect disk devices through GEOM."
msgstr "如何通过 GEOM 镜像、磁条、加密和远程连接磁盘设备。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:67
msgid "How to troubleshoot disks attached to the GEOM framework."
msgstr "如何对连接到 GEOM 框架的磁盘进行故障排除。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:69
msgid "Before reading this chapter, you should:"
msgstr "在阅读本章之前，你应该："

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:71
msgid "Understand how FreeBSD treats disk devices (crossref:disks[disks,Storage])."
msgstr "了解 FreeBSD 是如何处理磁盘设备的（存储）。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:72
msgid "Know how to configure and install a new kernel (crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."
msgstr "知道如何配置和安装新的内核（crossref:kernelconfig[kernelconfig,配置 FreeBSD 内核]）。"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:74
#, no-wrap
msgid "RAID0 - Striping"
msgstr "RAID0 - 条带"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:79
msgid ""
"Striping combines several disk drives into a single volume.  Striping can be performed through the use of hardware RAID controllers.  The GEOM disk subsystem provides software "
"support for disk striping, also known as RAID0, without the need for a RAID disk controller."
msgstr "条带化将几个磁盘驱动器组合成一个卷。条带化可以通过使用硬件 RAID 控制器来进行。GEOM 磁盘子系统为磁盘条带化提供软件支持，也称为 RAID0 ，不需要 RAID 磁盘控制器。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:83
msgid ""
"In RAID0, data is split into blocks that are written across all the drives in the array.  As seen in the following illustration, instead of having to wait on the system to write "
"256k to one disk, RAID0 can simultaneously write 64k to each of the four disks in the array, offering superior I/O performance.  This performance can be enhanced further by "
"using multiple disk controllers."
msgstr ""
"在 RAID0 中，数据被分割成块，在阵列中的所有驱动器上写入。如下图所示，RAID0 不需要等待系统向一个磁盘写入 256k 的数据，而是可以同时向阵列中的四个磁盘各写入 64k 的数据，从而提供卓越"
"的 I/O 性能。这种性能可以通过使用多个磁盘控制器进一步增强。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: content/zh-cn/books/handbook/geom/_index.adoc:84
#, no-wrap
msgid "Disk Striping Illustration"
msgstr "磁盘条带化说明"

#. type: Target for macro image
#: content/zh-cn/books/handbook/geom/_index.adoc:84
#, no-wrap
msgid "striping.png"
msgstr "striping.png"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:87
msgid "Each disk in a RAID0 stripe must be of the same size, since I/O requests are interleaved to read or write to multiple disks in parallel."
msgstr "RAID0 条带中的每个磁盘必须具有相同的大小，因为 I/O 请求是交错进行的，以平行地读或写到多个磁盘。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:93
msgid ""
"RAID0 does _not_ provide any redundancy.  This means that if one disk in the array fails, all of the data on the disks is lost.  If the data is important, implement a backup "
"strategy that regularly saves backups to a remote system or device."
msgstr "RAID0 不提供任何冗余。这意味着，如果阵列中的一个磁盘发生故障，磁盘上的所有数据都会丢失。如果数据很重要，实施一个备份策略，定期将备份保存到远程系统或设备上。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:97
msgid ""
"The process for creating a software, GEOM-based RAID0 on a FreeBSD system using commodity disks is as follows.  Once the stripe is created, refer to man:gstripe[8] for more "
"information on how to control an existing stripe."
msgstr "在 FreeBSD 系统上使用商品磁盘创建一个基于 GEOM 的软件 RAID0 的过程如下。如果创建了条带，请参考 man:gstripe[8] 以了解更多关于如何控制现有条带的信息。"

#. type: delimited block * 4
#: content/zh-cn/books/handbook/geom/_index.adoc:101
#, no-wrap
msgid "*Procedure: Creating a Stripe of Unformatted ATA Disks*\n"
msgstr "*程序：创建未格式化的ATA磁盘条带*\n"

#. type: delimited block * 4
#: content/zh-cn/books/handbook/geom/_index.adoc:103
msgid "Load the [.filename]#geom_stripe.ko# module:"
msgstr "加载 [.filename]#geom_stripe.ko# 模块："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:107
#, no-wrap
msgid "# kldload geom_stripe\n"
msgstr "# kldload geom_stripe\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:110
msgid "Ensure that a suitable mount point exists. If this volume will become a root partition, then temporarily use another mount point such as [.filename]#/mnt#."
msgstr "确保存在一个合适的挂载点。如果这个卷将成为一个根分区，那么暂时使用另一个挂载点，如 [.filename]#/mnt#"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:111
msgid ""
"Determine the device names for the disks which will be striped, and create the new stripe device. For example, to stripe two unused and unpartitioned ATA disks with device names "
"of [.filename]#/dev/ad2# and [.filename]#/dev/ad3#:"
msgstr "确定要条带化的磁盘的设备名称，并创建新的条带设备。例如，要对两个未使用和未分区的 ATA 磁盘进行条带化，设备名称为 [.filename]#/dev/ad2# 和 [.filename]#/dev/ad3# 。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:118
#, no-wrap
msgid ""
"# gstripe label -v st0 /dev/ad2 /dev/ad3\n"
"Metadata value stored on /dev/ad2.\n"
"Metadata value stored on /dev/ad3.\n"
"Done.\n"
msgstr ""
"# gstripe label -v st0 /dev/ad2 /dev/ad3\n"
"Metadata value stored on /dev/ad2.\n"
"Metadata value stored on /dev/ad3.\n"
"Done.\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:121
msgid "Write a standard label, also known as a partition table, on the new volume and install the default bootstrap code:"
msgstr "在新卷上写一个标准标签，也称为分区表，并安装默认的引导代码。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:125
#, no-wrap
msgid "# bsdlabel -wB /dev/stripe/st0\n"
msgstr "# bsdlabel -wB /dev/stripe/st0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:128
msgid ""
"This process should create two other devices in [.filename]#/dev/stripe# in addition to [.filename]#st0#. Those include [.filename]#st0a# and [.filename]#st0c#. At this point, a "
"UFS file system can be created on [.filename]#st0a# using `newfs`:"
msgstr ""
"这个过程应该在 [.filename]#/dev/stripe# 中创建除 [.filename]#st0# 之外的另外两个设备。这些设备包括 [.filename]#st0a# 和 [.filename]#st0c# 。在这一点上，"
"可以使用 `newfs` 在 [.filename]#st0a# 上创建一个 UFS 文件系统。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:132
#, no-wrap
msgid "# newfs -U /dev/stripe/st0a\n"
msgstr "# newfs -U /dev/stripe/st0a\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:136
msgid "Many numbers will glide across the screen, and after a few seconds, the process will be complete.  The volume has been created and is ready to be mounted."
msgstr "许多数字会在屏幕上滑过，几秒钟后，这个过程就完成了。卷已经被创建，并准备好被挂载。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:137
msgid "To manually mount the created disk stripe:"
msgstr "要手动挂载创建的磁盘条带："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:141
#, no-wrap
msgid "# mount /dev/stripe/st0a /mnt\n"
msgstr "# mount /dev/stripe/st0a /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:144
msgid ""
"To mount this striped file system automatically during the boot process, place the volume information in [.filename]#/etc/fstab#. In this example, a permanent mount point, named "
"[.filename]#stripe#, is created:"
msgstr "为了在启动过程中自动挂载这个带状文件系统，把卷的信息放在 [.filename]#/etc/fstab# 中。在这个例子中，创建了一个永久的挂载点，名为 [.filename]#stripe# 。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:150
#, no-wrap
msgid ""
"# mkdir /stripe\n"
"# echo \"/dev/stripe/st0a /stripe ufs rw 2 2\" \\\n"
">> /etc/fstab\n"
msgstr ""
"# mkdir /stripe\n"
"# echo \"/dev/stripe/st0a /stripe ufs rw 2 2\" \\\n"
">> /etc/fstab\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:153
msgid "The [.filename]#geom_stripe.ko# module must also be automatically loaded during system initialization, by adding a line to [.filename]#/boot/loader.conf#:"
msgstr "[.filename]#geom_stripe.ko# 模块也必须在系统初始化时自动加载，方法是在 [.filename]#/boot/loader.conf# 中添加一行。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:157
#, no-wrap
msgid "# echo 'geom_stripe_load=\"YES\"' >> /boot/loader.conf\n"
msgstr "# echo 'geom_stripe_load=\"YES\"' >> /boot/loader.conf\n"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:161
#, no-wrap
msgid "RAID1 - Mirroring"
msgstr "RAID1 - 镜像"

#. type: delimited block * 4
#: content/zh-cn/books/handbook/geom/_index.adoc:168
msgid ""
"RAID1, or _mirroring_, is the technique of writing the same data to more than one disk drive.  Mirrors are usually used to guard against data loss due to drive failure.  Each "
"drive in a mirror contains an identical copy of the data.  When an individual drive fails, the mirror continues to work, providing data from the drives that are still "
"functioning.  The computer keeps running, and the administrator has time to replace the failed drive without user interruption."
msgstr ""
"RAID1，或称镜像，是将相同的数据写入一个以上的磁盘驱动器的技术。镜像通常被用来防止因驱动器故障而导致的数据丢失。镜像中的每个驱动器都包含一个相同的数据副本。当一个单独的驱动器发生"
"故障时，镜像继续工作，提供来自仍在运行的驱动器的数据。计算机继续运行，管理员有时间在不影响用户的情况下更换故障驱动器。"

#. type: delimited block * 4
#: content/zh-cn/books/handbook/geom/_index.adoc:173
msgid ""
"Two common situations are illustrated in these examples.  The first creates a mirror out of two new drives and uses it as a replacement for an existing single drive.  The second "
"example creates a mirror on a single new drive, copies the old drive's data to it, then inserts the old drive into the mirror.  While this procedure is slightly more "
"complicated, it only requires one new drive."
msgstr ""
"这些例子中说明了两种常见的情况。第一个例子是用两个新的驱动器创建一个镜像，用它来替代现有的单个驱动器。第二个例子在一个新的驱动器上创建一个镜像，把旧的驱动器的数据复制到它上面，然"
"后把旧的驱动器插入镜像中。虽然这个过程稍微复杂一些，但它只需要一个新的驱动器。"

#. type: delimited block * 4
#: content/zh-cn/books/handbook/geom/_index.adoc:178
msgid ""
"Traditionally, the two drives in a mirror are identical in model and capacity, but man:gmirror[8] does not require that.  Mirrors created with dissimilar drives will have a "
"capacity equal to that of the smallest drive in the mirror.  Extra space on larger drives will be unused.  Drives inserted into the mirror later must have at least as much "
"capacity as the smallest drive already in the mirror."
msgstr ""
"传统上，镜像中的两个驱动器在型号和容量上是相同的，但是 man:gmirror[8] 并不要求这样。用不同的驱动器创建的镜像，其容量等于镜像中最小的驱动器的容量。较大驱动器上的额外空间将不被使"
"用。后来插入镜像的硬盘必须至少有与镜像中最小的硬盘一样的容量。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:182
msgid "The mirroring procedures shown here are non-destructive, but as with any major disk operation, make a full backup first."
msgstr "这里显示的镜像步骤是非破坏性的，但与任何主要的磁盘操作一样，先做一个完整的备份。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:188
msgid ""
"While man:dump[8] is used in these procedures to copy file systems, it does not work on file systems with soft updates journaling.  See man:tunefs[8] for information on "
"detecting and disabling soft updates journaling."
msgstr "虽然 man:dump[8] 在这些程序中被用来复制文件系统，但它对有软更新日志的文件系统不起作用。参见 man:tunefs[8] 以获得关于检测和禁用软更新日志的信息。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:191
#, no-wrap
msgid "Metadata Issues"
msgstr "元数据问题"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:196
msgid ""
"Many disk systems store metadata at the end of each disk.  Old metadata should be erased before reusing the disk for a mirror.  Most problems are caused by two particular types "
"of leftover metadata: GPT partition tables and old metadata from a previous mirror."
msgstr "许多磁盘系统在每个磁盘的末端存储元数据。在重新使用磁盘做镜像之前，旧的元数据应该被擦除。大多数问题是由两种特殊类型的遗留元数据引起的。GPT 分区表和之前镜像的旧元数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:199
msgid "GPT metadata can be erased with man:gpart[8].  This example erases both primary and backup GPT partition tables from disk [.filename]#ada8#:"
msgstr "GPT 元数据可以用 man:gpart[8] 来擦除。这个例子删除了 [.filename]#ada8# 磁盘上的主分区和备份 GPT 分区表。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:203
#, no-wrap
msgid "# gpart destroy -F ada8\n"
msgstr "# gpart destroy -F ada8\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:207
msgid ""
"A disk can be removed from an active mirror and the metadata erased in one step using man:gmirror[8].  Here, the example disk [.filename]#ada8# is removed from the active mirror "
"[.filename]#gm4#:"
msgstr "使用 man:gmirror[8] 可以将一个磁盘从活动镜像中移除，并在一个步骤中擦除元数据。这里，例子中的磁盘 [.filename]#ada8# 被从活动镜像 [.filename]#gm4# 中移除。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:211
#, no-wrap
msgid "# gmirror remove gm4 ada8\n"
msgstr "# gmirror remove gm4 ada8\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:214
msgid "If the mirror is not running, but old mirror metadata is still on the disk, use `gmirror clear` to remove it:"
msgstr "如果镜像没有运行，但是旧的镜像元数据仍然在磁盘上，使用 `gmirror clear` 来移除它。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:218
#, no-wrap
msgid "# gmirror clear ada8\n"
msgstr "# gmirror clear ada8\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:223
msgid ""
"man:gmirror[8] stores one block of metadata at the end of the disk.  As GPT partition schemes also store metadata at the end of the disk, mirroring entire GPT disks with man:"
"gmirror[8] is not recommended.  MBR partitioning is used here because it only stores a partition table at the start of the disk and does not conflict with the mirror metadata."
msgstr ""
"man:gmirror[8] 在磁盘的末端存储一个元数据块。由于 GPT 分区方案也在磁盘的末端存储元数据，所以不推荐用 man:gmirror[8] 来镜像整个 GPT 磁盘。这里使用 MBR 分区，因为它只在磁盘的开始部"
"分存储一个分区表，不会与镜像元数据冲突。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:225
#, no-wrap
msgid "Creating a Mirror with Two New Disks"
msgstr "用两个新磁盘创建一个镜像"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:230
msgid ""
"In this example, FreeBSD has already been installed on a single disk, [.filename]#ada0#.  Two new disks, [.filename]#ada1# and [.filename]#ada2#, have been connected to the "
"system.  A new mirror will be created on these two disks and used to replace the old single disk."
msgstr ""
"在这个例子中，FreeBSD 已经被安装在一个单一的磁盘上，即 [.filename]#ada0# 。两个新的磁盘，[.filename]#ada1# 和 [.filename]#ada2#，已经被连接到系统中。在这两个磁盘上将创建一个新的"
"镜像，用来替换旧的单磁盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:233
msgid "The [.filename]#geom_mirror.ko# kernel module must either be built into the kernel or loaded at boot- or run-time.  Manually load the kernel module now:"
msgstr "[.filename]#geom_mirror.ko# 内核模块必须被内置到内核中，或者在启动或运行时加载。现在手动加载内核模块。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:237 content/zh-cn/books/handbook/geom/_index.adoc:359
#, no-wrap
msgid "# gmirror load\n"
msgstr "# gmirror load\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:240
msgid "Create the mirror with the two new drives:"
msgstr "用两个新的驱动器创建镜像。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:244
#, no-wrap
msgid "# gmirror label -v gm0 /dev/ada1 /dev/ada2\n"
msgstr "# gmirror label -v gm0 /dev/ada1 /dev/ada2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:248
msgid "[.filename]#gm0# is a user-chosen device name assigned to the new mirror.  After the mirror has been started, this device name appears in [.filename]#/dev/mirror/#."
msgstr "[.filename]#gm0# 是一个用户选择的设备名称，分配给新的镜像。镜像启动后，这个设备名出现在 [.filename]#/dev/mirror/# 中。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:252
msgid ""
"MBR and bsdlabel partition tables can now be created on the mirror with man:gpart[8].  This example uses a traditional file system layout, with partitions for [.filename]#/#, "
"swap, [.filename]#/var#, [.filename]#/tmp#, and [.filename]#/usr#.  A single [.filename]#/# and a swap partition will also work."
msgstr ""
"现在可以用 man:gpart[8] 在镜像上创建 MBR 和 bsdlabel 分区表。这个例子使用了传统的文件系统布局，有 [.filename]#/#、 swap 、 [.filename]#/var# 、[.filename]#/tmp# 和 [.filename]#/usr#"
" 分区。一个单一的 [.filename]#/# 和一个交换分区也可以工作。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:254
msgid ""
"Partitions on the mirror do not have to be the same size as those on the existing disk, but they must be large enough to hold all the data already present on [.filename]#ada0#."
msgstr "镜像上的分区不一定要和现有磁盘上的分区一样大，但它们必须大到足以容纳 [.filename]#ada0# 上已有的所有数据。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:264
#, no-wrap
msgid ""
"# gpart create -s MBR mirror/gm0\n"
"# gpart add -t freebsd -a 4k mirror/gm0\n"
"# gpart show mirror/gm0\n"
"=>       63  156301423  mirror/gm0  MBR  (74G)\n"
"         63         63                    - free -  (31k)\n"
"        126  156301299                 1  freebsd  (74G)\n"
"  156301425         61                    - free -  (30k)\n"
msgstr ""
"# gpart create -s MBR mirror/gm0\n"
"# gpart add -t freebsd -a 4k mirror/gm0\n"
"# gpart show mirror/gm0\n"
"=>       63  156301423  mirror/gm0  MBR  (74G)\n"
"         63         63                    - free -  (31k)\n"
"        126  156301299                 1  freebsd  (74G)\n"
"  156301425         61                    - free -  (30k)\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:283
#, no-wrap
msgid ""
"# gpart create -s BSD mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k mirror/gm0s1\n"
"# gpart show mirror/gm0s1\n"
"=>        0  156301299  mirror/gm0s1  BSD  (74G)\n"
"          0          2                      - free -  (1.0k)\n"
"          2    4194304                   1  freebsd-ufs  (2.0G)\n"
"    4194306    8388608                   2  freebsd-swap (4.0G)\n"
"   12582914    4194304                   4  freebsd-ufs  (2.0G)\n"
"   16777218    2097152                   5  freebsd-ufs  (1.0G)\n"
"   18874370  137426928                   6  freebsd-ufs  (65G)\n"
"  156301298          1                      - free -  (512B)\n"
msgstr ""
"# gpart create -s BSD mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k mirror/gm0s1\n"
"# gpart show mirror/gm0s1\n"
"=>        0  156301299  mirror/gm0s1  BSD  (74G)\n"
"          0          2                      - free -  (1.0k)\n"
"          2    4194304                   1  freebsd-ufs  (2.0G)\n"
"    4194306    8388608                   2  freebsd-swap (4.0G)\n"
"   12582914    4194304                   4  freebsd-ufs  (2.0G)\n"
"   16777218    2097152                   5  freebsd-ufs  (1.0G)\n"
"   18874370  137426928                   6  freebsd-ufs  (65G)\n"
"  156301298          1                      - free -  (512B)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:286 content/zh-cn/books/handbook/geom/_index.adoc:504
msgid "Make the mirror bootable by installing bootcode in the MBR and bsdlabel and setting the active slice:"
msgstr "通过在 MBR 和 bsdlabel 中安装 bootcode 并设置活动片，使镜像可启动。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:292 content/zh-cn/books/handbook/geom/_index.adoc:510
#, no-wrap
msgid ""
"# gpart bootcode -b /boot/mbr mirror/gm0\n"
"# gpart set -a active -i 1 mirror/gm0\n"
"# gpart bootcode -b /boot/boot mirror/gm0s1\n"
msgstr ""
"# gpart bootcode -b /boot/mbr mirror/gm0\n"
"# gpart set -a active -i 1 mirror/gm0\n"
"# gpart bootcode -b /boot/boot mirror/gm0s1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:295
msgid "Format the file systems on the new mirror, enabling soft-updates."
msgstr "格式化新镜像上的文件系统，启用软更新。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:302
#, no-wrap
msgid ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"
msgstr ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:305
msgid "File systems from the original [.filename]#ada0# disk can now be copied onto the mirror with man:dump[8] and man:restore[8]."
msgstr "现在可以用 man:dump[8] 和 man:restore[8] 将原始 [.filename]#ada0# 磁盘上的文件系统复制到镜像上。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:316
#, no-wrap
msgid ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - / | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/tmp\n"
"# mount /dev/mirror/gm0s1f /mnt/usr\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"
msgstr ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - / | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/tmp\n"
"# mount /dev/mirror/gm0s1f /mnt/usr\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:319
msgid "Edit [.filename]#/mnt/etc/fstab# to point to the new mirror file systems:"
msgstr "编辑 [.filename]#/mnt/etc/fstab# 以指向新的镜像文件系统。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:328
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/tmp\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/usr\t\tufs\trw\t2\t2\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/tmp\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/usr\t\tufs\trw\t2\t2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:331
msgid "If the [.filename]#geom_mirror.ko# kernel module has not been built into the kernel, [.filename]#/mnt/boot/loader.conf# is edited to load the module at boot:"
msgstr "如果 [.filename]#geom_mirror.ko# 内核模块没有被内置到内核中，编辑 [.filename]#/mnt/boot/loader.conf# 以在启动时加载该模块。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:335 content/zh-cn/books/handbook/geom/_index.adoc:538 content/zh-cn/books/handbook/geom/_index.adoc:651
#, no-wrap
msgid "geom_mirror_load=\"YES\"\n"
msgstr "geom_mirror_load=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:340
msgid ""
"Reboot the system to test the new mirror and verify that all data has been copied.  The BIOS will see the mirror as two individual drives rather than a mirror.  Since the drives "
"are identical, it does not matter which is selected to boot."
msgstr "重新启动系统以测试新的镜像，并验证所有数据是否已经复制。BIOS 会把镜像看作是两个独立的硬盘，而不是一个镜像。由于这两个硬盘是相同的，所以选择哪一个来启动并不重要。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:343
msgid ""
"See <<gmirror-troubleshooting>> if there are problems booting.  Powering down and disconnecting the original [.filename]#ada0# disk will allow it to be kept as an offline backup."
msgstr "如果启动有问题，请参见故障排除。关掉电源并断开原始 [.filename]#ada0# 磁盘的连接，可以将其作为离线备份保存。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:345
msgid "In use, the mirror will behave just like the original single drive."
msgstr "在使用中，镜像的行为就像原来的单盘一样。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:347
#, no-wrap
msgid "Creating a Mirror with an Existing Drive"
msgstr "用现有的驱动器创建一个镜像"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:353
msgid ""
"In this example, FreeBSD has already been installed on a single disk, [.filename]#ada0#.  A new disk, [.filename]#ada1#, has been connected to the system.  A one-disk mirror "
"will be created on the new disk, the existing system copied onto it, and then the old disk will be inserted into the mirror.  This slightly complex procedure is required because "
"`gmirror` needs to put a 512-byte block of metadata at the end of each disk, and the existing [.filename]#ada0# has usually had all of its space already allocated."
msgstr ""
"在这个例子中，FreeBSD 已经被安装在一个单一的磁盘上，即 [.filename]#ada0# 。一个新的磁盘，[.filename]#ada1# ，已经被连接到系统中。在新的磁盘上将创建一个单盘镜像，将现有的系统复制"
"到上面，然后将旧的磁盘插入镜像中。这个稍微复杂的过程是需要的，因为 gmirror 需要在每个磁盘的末尾放一个 512 字节的元数据块，而现有的 [.filename]#ada0# 通常已经分配了所有的空间。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:355
msgid "Load the [.filename]#geom_mirror.ko# kernel module:"
msgstr "加载 [.filename]#geom_mirror.ko# 内核模块。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:362
msgid "Check the media size of the original disk with `diskinfo`:"
msgstr "用 `diskinfo` 检查原始磁盘的介质大小。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:369
#, no-wrap
msgid ""
"# diskinfo -v ada0 | head -n3\n"
"/dev/ada0\n"
"        512             # sectorsize\n"
"        1000204821504   # mediasize in bytes (931G)\n"
msgstr ""
"# diskinfo -v ada0 | head -n3\n"
"/dev/ada0\n"
"        512             # sectorsize\n"
"        1000204821504   # mediasize in bytes (931G)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:376
msgid ""
"Create a mirror on the new disk.  To make certain that the mirror capacity is not any larger than the original [.filename]#ada0# drive, man:gnop[8] is used to create a fake "
"drive of the exact same size.  This drive does not store any data, but is used only to limit the size of the mirror.  When man:gmirror[8] creates the mirror, it will restrict "
"the capacity to the size of [.filename]#gzero.nop#, even if the new [.filename]#ada1# drive has more space.  Note that the _1000204821504_ in the second line is equal to [."
"filename]#ada0#'s media size as shown by `diskinfo` above."
msgstr ""
"在新磁盘上创建一个镜像。为了确保镜像的容量不比原来的 [.filename]#ada0# 驱动器大，man:gnop[8] 被用来创建一个大小完全相同的假驱动器。这个驱动器不存储任何数据，只是用来限制镜像的大"
"小。当 man:gmirror[8] 创建镜像时，它将把容量限制在 [.filename]#gzero.nop# 的大小，即使新的 [.filename]#ada1# 驱动器有更多的空间。注意，第二行中的 _1000204821504_ 等于上面 "
"`diskinfo` 显示的 [.filename]#ada0#' 的介质大小。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:383
#, no-wrap
msgid ""
"# geom zero load\n"
"# gnop create -s 1000204821504 gzero\n"
"# gmirror label -v gm0 gzero.nop ada1\n"
"# gmirror forget gm0\n"
msgstr ""
"# geom zero load\n"
"# gnop create -s 1000204821504 gzero\n"
"# gmirror label -v gm0 gzero.nop ada1\n"
"# gmirror forget gm0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:388
msgid ""
"Since [.filename]#gzero.nop# does not store any data, the mirror does not see it as connected.  The mirror is told to \"forget\" unconnected components, removing references to [."
"filename]#gzero.nop#.  The result is a mirror device containing only a single disk, [.filename]#ada1#."
msgstr ""
"由于 [.filename]#gzero.nop# 不存储任何数据，镜像不会将其视为连接。镜像被告知要“忘记”未连接的组件，删除对 [.filename]#gzero.nop# 的引用。结果是一个镜像设备只包含一个磁盘，"
"[.filename]#ada1# 。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:392
msgid ""
"After creating [.filename]#gm0#, view the partition table on [.filename]#ada0#.  This output is from a 1 TB drive.  If there is some unallocated space at the end of the drive, "
"the contents may be copied directly from [.filename]#ada0# to the new mirror."
msgstr ""
"创建 [.filename]#gm0# 后，查看 [.filename]#ada0# 的分区表。这个输出是来自一个 1TB 的驱动器。如果在驱动器的末端有一些未分配的空间，内容可以直接从 [.filename]#ada0# 复制到新的镜"
"像。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:394
msgid ""
"However, if the output shows that all of the space on the disk is allocated, as in the following listing, there is no space available for the 512-byte mirror metadata at the end "
"of the disk."
msgstr "但是，如果输出显示磁盘上的所有空间都被分配了，就像下面的列表一样，那么磁盘末端的 512 字节的镜像元数据就没有可用空间了："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:400
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>        63  1953525105        ada0  MBR  (931G)\n"
"          63  1953525105           1  freebsd  [active]  (931G)\n"
msgstr ""
"# gpart show ada0\n"
"=>        63  1953525105        ada0  MBR  (931G)\n"
"          63  1953525105           1  freebsd  [active]  (931G)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:404
msgid "In this case, the partition table must be edited to reduce the capacity by one sector on [.filename]#mirror/gm0#.  The procedure will be explained later."
msgstr "在这种情况下，必须编辑分区表以减少镜像 [.filename]#mirror/gm0# 上一个扇区的容量。这个过程将在后面解释。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:406
msgid "In either case, partition tables on the primary disk should be first copied using `gpart backup` and `gpart restore`."
msgstr "在这两种情况下，应首先使用 `gpart backup` 和 `gpart restore` 来复制主磁盘上的分区表："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:411
#, no-wrap
msgid ""
"# gpart backup ada0 > table.ada0\n"
"# gpart backup ada0s1 > table.ada0s1\n"
msgstr ""
"# gpart backup ada0 > table.ada0\n"
"# gpart backup ada0s1 > table.ada0s1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:415
msgid "These commands create two files, [.filename]#table.ada0# and [.filename]#table.ada0s1#.  This example is from a 1 TB drive:"
msgstr "这些命令创建了两个文件，[.filename]#table.ada0# 和 [.filename]#table.ada0s1# 。这个例子来自一个 1TB 的硬盘："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:421
#, no-wrap
msgid ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525105   [active]\n"
msgstr ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525105   [active]\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:433
#, no-wrap
msgid ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640881\n"
msgstr ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640881\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:438
msgid ""
"If no free space is shown at the end of the disk, the size of both the slice and the last partition must be reduced by one sector.  Edit the two files, reducing the size of both "
"the slice and last partition by one.  These are the last numbers in each listing."
msgstr "如果在磁盘的末端没有显示出自由空间，那么分片和最后一个分区的大小都必须减少一个扇区。编辑这两个文件，将分片和最后一个分区的大小都减少一个。这些是每个列表中的最后数字："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:444
#, no-wrap
msgid ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525104   [active]\n"
msgstr ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525104   [active]\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:456
#, no-wrap
msgid ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640880\n"
msgstr ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640880\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:459
msgid "If at least one sector was unallocated at the end of the disk, these two files can be used without modification."
msgstr "如果在磁盘的末端至少有一个扇区没有被分配，这两个文件可以不加修改地使用。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:461
msgid "Now restore the partition table into [.filename]#mirror/gm0#:"
msgstr "现在将分区表恢复到 [.filename]#mirror/gm0# ："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:466
#, no-wrap
msgid ""
"# gpart restore mirror/gm0 < table.ada0\n"
"# gpart restore mirror/gm0s1 < table.ada0s1\n"
msgstr ""
"# gpart restore mirror/gm0 < table.ada0\n"
"# gpart restore mirror/gm0s1 < table.ada0s1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:470
msgid ""
"Check the partition table with `gpart show`.  This example has [.filename]#gm0s1a# for [.filename]#/#, [.filename]#gm0s1d# for [.filename]#/var#, [.filename]#gm0s1e# for [."
"filename]#/usr#, [.filename]#gm0s1f# for [.filename]#/data1#, and [.filename]#gm0s1g# for [.filename]#/data2#."
msgstr ""
"用 `gpart show` 检查分区表。这个例子中，[.filename]#gm0s1a# 代表 [.filename]#/# ，[.filename]#gm0s1d# 代表 [.filename]#/var# ，[.filename]#gm0s1e# 代表 [.filename]#/usr# ，"
"[.filename]#gm0s1f# 代表 [.filename]#/data1# ，而 [.filename]#gm0s1g# 代表 [.filename]#/data2#："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:477
#, no-wrap
msgid ""
"# gpart show mirror/gm0\n"
"=>        63  1953525104  mirror/gm0  MBR  (931G)\n"
"          63  1953525042           1  freebsd  [active]  (931G)\n"
"  1953525105          62              - free -  (31k)\n"
msgstr ""
"# gpart show mirror/gm0\n"
"=>        63  1953525104  mirror/gm0  MBR  (931G)\n"
"          63  1953525042           1  freebsd  [active]  (931G)\n"
"  1953525105          62              - free -  (31k)\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:487
#, no-wrap
msgid ""
"# gpart show mirror/gm0s1\n"
"=>         0  1953525042  mirror/gm0s1  BSD  (931G)\n"
"           0     2097152             1  freebsd-ufs  (1.0G)\n"
"     2097152    16777216             2  freebsd-swap  (8.0G)\n"
"    18874368    41943040             4  freebsd-ufs  (20G)\n"
"    60817408    20971520             5  freebsd-ufs  (10G)\n"
"    81788928   629145600             6  freebsd-ufs  (300G)\n"
"   710934528  1242590514             7  freebsd-ufs  (592G)\n"
"  1953525042          63                - free -  (31k)\n"
msgstr ""
"# gpart show mirror/gm0s1\n"
"=>         0  1953525042  mirror/gm0s1  BSD  (931G)\n"
"           0     2097152             1  freebsd-ufs  (1.0G)\n"
"     2097152    16777216             2  freebsd-swap  (8.0G)\n"
"    18874368    41943040             4  freebsd-ufs  (20G)\n"
"    60817408    20971520             5  freebsd-ufs  (10G)\n"
"    81788928   629145600             6  freebsd-ufs  (300G)\n"
"   710934528  1242590514             7  freebsd-ufs  (592G)\n"
"  1953525042          63                - free -  (31k)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:490
msgid "Both the slice and the last partition must have at least one free block at the end of the disk."
msgstr "分片和最后一个分区都必须在磁盘的末端有至少一个空闲块。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:493
msgid "Create file systems on these new partitions.  The number of partitions will vary to match the original disk, [.filename]#ada0#."
msgstr "在这些新分区上创建文件系统。分区的数量将有所不同，以配合原始磁盘，即 [.filename]#ada0# ："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:501
#, no-wrap
msgid ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"
"# newfs -U /dev/mirror/gm0s1g\n"
msgstr ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"
"# newfs -U /dev/mirror/gm0s1g\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:514
msgid "Adjust [.filename]#/etc/fstab# to use the new partitions on the mirror.  Back up this file first by copying it to [.filename]#/etc/fstab.orig#."
msgstr "调整 [.filename]#/etc/fstab# 以使用镜像上的新分区。先把这个文件复制到 [.filename]#/etc/fstab.orig# ，以此来备份："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:518
#, no-wrap
msgid "# cp /etc/fstab /etc/fstab.orig\n"
msgstr "# cp /etc/fstab /etc/fstab.orig\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:521
msgid "Edit [.filename]#/etc/fstab#, replacing [.filename]#/dev/ada0# with [.filename]#mirror/gm0#."
msgstr "编辑 [.filename]#/etc/fstab# ，将 [.filename]#/dev/ada0# 替换为 [.filename]#mirror/gm0# ："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:531
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/usr\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/data1\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1g\t/data2\t\tufs\trw\t2\t2\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/usr\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/data1\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1g\t/data2\t\tufs\trw\t2\t2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:534
msgid "If the [.filename]#geom_mirror.ko# kernel module has not been built into the kernel, edit [.filename]#/boot/loader.conf# to load it at boot:"
msgstr "如果 [.filename]#geom_mirror.ko# 内核模块没有被内置到内核中，编辑 [.filename]#/boot/loader.conf# 在启动时加载它："

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:542
msgid ""
"File systems from the original disk can now be copied onto the mirror with man:dump[8] and man:restore[8].  Each file system dumped with `dump -L` will create a snapshot first, "
"which can take some time."
msgstr "现在可以用 man:dump[8] 和 man:restore[8] 将原始磁盘的文件系统复制到镜像上。用 `dump -L` 转储的每个文件系统都会先创建一个快照，这可能需要一些时间："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:555
#, no-wrap
msgid ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - /    | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/usr\n"
"# mount /dev/mirror/gm0s1f /mnt/data1\n"
"# mount /dev/mirror/gm0s1g /mnt/data2\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 && restore -rf -)\n"
msgstr ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - /    | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/usr\n"
"# mount /dev/mirror/gm0s1f /mnt/data1\n"
"# mount /dev/mirror/gm0s1g /mnt/data2\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 && restore -rf -)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:560
msgid ""
"Restart the system, booting from [.filename]#ada1#.  If everything is working, the system will boot from [.filename]#mirror/gm0#, which now contains the same data as [."
"filename]#ada0# had previously.  See <<gmirror-troubleshooting>> if there are problems booting."
msgstr ""
"重新启动系统，从 [.filename]#ada1# 启动。如果一切正常，系统将从 [.filename]#mirror/gm0# 启动，现在 [.filename]#mirror/gm0# 包含的数据与 [.filename]#ada0# 之前的一样。如果启动有问"
"题，请看故障排除。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:562
msgid "At this point, the mirror still consists of only the single [.filename]#ada1# disk."
msgstr "在这一点上，镜像仍然只包括单一的 [.filename]#ada1# 磁盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:564
msgid "After booting from [.filename]#mirror/gm0# successfully, the final step is inserting [.filename]#ada0# into the mirror."
msgstr "从 [.filename]#mirror/gm0# 成功启动后，最后一步是将 [.filename]#ada0# 插入镜像中。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:570
msgid ""
"When [.filename]#ada0# is inserted into the mirror, its former contents will be overwritten by data from the mirror.  Make certain that [.filename]#mirror/gm0# has the same "
"contents as [.filename]#ada0# before adding [.filename]#ada0# to the mirror.  If the contents previously copied by man:dump[8] and man:restore[8] are not identical to what was "
"on [.filename]#ada0#, revert [.filename]#/etc/fstab# to mount the file systems on [.filename]#ada0#, reboot, and start the whole procedure again."
msgstr ""
"当 [.filename]#ada0# 被插入镜像时，它以前的内容会被镜像的数据覆盖。在将 [.filename]#ada0# 加入镜像之前，请确定 [.filename]#mirror/gm0# 的内容与 [.filename]#ada0# 相同。如果之前通"
"过 man:dump[8] 和 man:restore[8] 复制的内容与 [.filename]#ada0# 上的内容不一致，请重新修改 [.filename]#/etc/fstab# ，将文件系统挂载到 [.filename]#ada0# 上，重新启动，然后重新开始"
"整个过程。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:576
#, no-wrap
msgid ""
"# gmirror insert gm0 ada0\n"
"GEOM_MIRROR: Device gm0: rebuilding provider ada0\n"
msgstr ""
"# gmirror insert gm0 ada0\n"
"GEOM_MIRROR: Device gm0: rebuilding provider ada0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:580
msgid "Synchronization between the two disks will start immediately.  Use `gmirror status` to view the progress."
msgstr "两个磁盘之间的同步将立即开始。使用 `gmirror status` 来查看进度。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:587
#, no-wrap
msgid ""
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  DEGRADED  ada1 (ACTIVE)\n"
"                      ada0 (SYNCHRONIZING, 64%)\n"
msgstr ""
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  DEGRADED  ada1 (ACTIVE)\n"
"                      ada0 (SYNCHRONIZING, 64%)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:590
msgid "After a while, synchronization will finish."
msgstr "一段时间后，同步将结束。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:598
#, no-wrap
msgid ""
"GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.\n"
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  COMPLETE  ada1 (ACTIVE)\n"
"                      ada0 (ACTIVE)\n"
msgstr ""
"GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.\n"
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  COMPLETE  ada1 (ACTIVE)\n"
"                      ada0 (ACTIVE)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:602
msgid ""
"[.filename]#mirror/gm0# now consists of the two disks [.filename]#ada0# and [.filename]#ada1#, and the contents are automatically synchronized with each other.  In use, [."
"filename]#mirror/gm0# will behave just like the original single drive."
msgstr "[.filename]#mirror/gm0# 现在由两个磁盘 [.filename]#ada0# 和 [.filename]#ada1# 组成，内容会自动相互同步。在使用中，[.filename]#mirror/gm0# 的行为就像原来的单硬盘一样。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:604
#, no-wrap
msgid "Troubleshooting"
msgstr "故障排除"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:608
msgid ""
"If the system no longer boots, BIOS settings may have to be changed to boot from one of the new mirrored drives.  Either mirror drive can be used for booting, as they contain "
"identical data."
msgstr "如果系统不再启动，可能需要改变 BIOS 设置，以便从新的镜像驱动器中的一个启动。任何一个镜像驱动器都可以用来启动，因为它们包含相同的数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:610
msgid "If the boot stops with this message, something is wrong with the mirror device:"
msgstr "如果启动停止时出现这个信息，说明镜像设备出了问题。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:614
#, no-wrap
msgid "Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.\n"
msgstr "Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:618
#, no-wrap
msgid ""
"Loader variables:\n"
"  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a\n"
"  vfs.root.mountfrom.options=rw\n"
msgstr ""
"Loader variables:\n"
"  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a\n"
"  vfs.root.mountfrom.options=rw\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:623
#, no-wrap
msgid ""
"Manual root filesystem specification:\n"
"  <fstype>:<device> [options]\n"
"      Mount <device> using filesystem <fstype>\n"
"      and with the specified (optional) option list.\n"
msgstr ""
"Manual root filesystem specification:\n"
"  <fstype>:<device> [options]\n"
"      Mount <device> using filesystem <fstype>\n"
"      and with the specified (optional) option list.\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:628
#, no-wrap
msgid ""
"    eg. ufs:/dev/da0s1a\n"
"        zfs:tank\n"
"        cd9660:/dev/acd0 ro\n"
"          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)\n"
msgstr ""
"    eg. ufs:/dev/da0s1a\n"
"        zfs:tank\n"
"        cd9660:/dev/acd0 ro\n"
"          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:632
#, no-wrap
msgid ""
"  ?               List valid disk boot devices\n"
"  .               Yield 1 second (for background tasks)\n"
"  <empty line>    Abort manual input\n"
msgstr ""
"  ?               List valid disk boot devices\n"
"  .               Yield 1 second (for background tasks)\n"
"  <empty line>    Abort manual input\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:634
#, no-wrap
msgid "mountroot>\n"
msgstr "mountroot>\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:639
msgid ""
"Forgetting to load the [.filename]#geom_mirror.ko# module in [.filename]#/boot/loader.conf# can cause this problem.  To fix it, boot from a FreeBSD installation media and choose "
"`Shell` at the first prompt.  Then load the mirror module and mount the mirror device:"
msgstr ""
"忘记在 [.filename]#/boot/loader.conf# 中加载 [.filename]#geom_mirror.ko# 模块会导致这个问题。要解决这个问题，从 FreeBSD 安装介质启动，在第一个提示符下选择 `Shell` 。然后加载镜像"
"模块并安装镜像设备。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:644
#, no-wrap
msgid ""
"# gmirror load\n"
"# mount /dev/mirror/gm0s1a /mnt\n"
msgstr ""
"# gmirror load\n"
"# mount /dev/mirror/gm0s1a /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:647
msgid "Edit [.filename]#/mnt/boot/loader.conf#, adding a line to load the mirror module:"
msgstr "编辑 [.filename]#/mnt/boot/loader.conf#，添加一行来加载镜像模块:"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:654
msgid "Save the file and reboot."
msgstr "保存该文件并重新启动。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:660
msgid ""
"Other problems that cause `error 19` require more effort to fix.  Although the system should boot from [.filename]#ada0#, another prompt to select a shell will appear if [."
"filename]#/etc/fstab# is incorrect.  Enter `ufs:/dev/ada0s1a` at the boot loader prompt and press kbd:[Enter].  Undo the edits in [.filename]#/etc/fstab# then mount the file "
"systems from the original disk ([.filename]#ada0#) instead of the mirror.  Reboot the system and try the procedure again."
msgstr ""
"其他导致 `error 19` 的问题需要更多的努力来解决。尽管系统应该从 [.filename]#ada0# 启动，但如果 [.filename]#/etc/fstab# 不正确，会出现另一个选择 shell 的提示。在 boot loader 提示下"
"输入 `ufs:/dev/ada0s1a` ，然后按 kbd:[Enter]。撤销 [.filename]#/etc/fstab# 中的编辑，然后从原始磁盘（[.filename]#ada0#）而不是镜像中加载文件系统。重新启动系统并再次尝试该过程。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:666
#, no-wrap
msgid ""
"Enter full pathname of shell or RETURN for /bin/sh:\n"
"# cp /etc/fstab.orig /etc/fstab\n"
"# reboot\n"
msgstr ""
"Enter full pathname of shell or RETURN for /bin/sh:\n"
"# cp /etc/fstab.orig /etc/fstab\n"
"# reboot\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:668
#, no-wrap
msgid "Recovering from Disk Failure"
msgstr "从磁盘故障中恢复"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:672
msgid ""
"The benefit of disk mirroring is that an individual disk can fail without causing the mirror to lose any data.  In the above example, if [.filename]#ada0# fails, the mirror will "
"continue to work, providing data from the remaining working drive, [.filename]#ada1#."
msgstr "磁盘镜像的好处是，一个单独的磁盘可以发生故障而不会导致镜像丢失任何数据。在上面的例子中，如果 ada0 发生故障，镜像将继续工作，从剩余的工作驱动器，ada1 提供数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:676
msgid ""
"To replace the failed drive, shut down the system and physically replace the failed drive with a new drive of equal or greater capacity.  Manufacturers use somewhat arbitrary "
"values when rating drives in gigabytes, and the only way to really be sure is to compare the total count of sectors shown by `diskinfo -v`.  A drive with larger capacity than "
"the mirror will work, although the extra space on the new drive will not be used."
msgstr ""
"要更换故障的硬盘，请关闭系统，用一个容量相同或更大的新硬盘物理替换故障的硬盘。制造商在以千兆字节为单位对硬盘进行评级时，使用了一些任意的数值，真正确定的唯一方法是比较 `diskinfo -v`"
" 所显示的扇区总数。一个容量大于镜像的驱动器可以工作，尽管新驱动器上的额外空间将不会被使用。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:679
msgid ""
"After the computer is powered back up, the mirror will be running in a \"degraded\" mode with only one drive.  The mirror is told to forget drives that are not currently "
"connected:"
msgstr "在计算机重新上电后，镜像将以“降级”模式运行，只有一个驱动器。镜像被告知要忘记当前没有连接的驱动器："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:683
#, no-wrap
msgid "# gmirror forget gm0\n"
msgstr "# gmirror forget gm0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:687
msgid ""
"Any old metadata should be cleared from the replacement disk using the instructions in <<geom-mirror-metadata>>.  Then the replacement disk, [.filename]#ada4# for this example, "
"is inserted into the mirror:"
msgstr "任何旧的元数据都应该按照元数据问题中的说明从替换磁盘中清除。然后将替换磁盘（本例中为 [.filename]#ada4#）插入镜像中："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:691
#, no-wrap
msgid "# gmirror insert gm0 /dev/ada4\n"
msgstr "# gmirror insert gm0 /dev/ada4\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:696
msgid ""
"Resynchronization begins when the new drive is inserted into the mirror.  This process of copying mirror data to a new drive can take a while.  Performance of the mirror will be "
"greatly reduced during the copy, so inserting new drives is best done when there is low demand on the computer."
msgstr ""
"当新的驱动器被插入镜像时，重新同步开始。这个将镜像数据复制到新驱动器的过程可能需要一段时间。在复制过程中，镜像的性能会大大降低，所以插入新的驱动器最好在计算机上的需求较低时进行。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:699
msgid ""
"Progress can be monitored with `gmirror status`, which shows drives that are being synchronized and the percentage of completion.  During resynchronization, the status will be "
"`DEGRADED`, changing to `COMPLETE` when the process is finished."
msgstr "可以用 `gmirror status` 监控进度，它显示正在同步的驱动器和完成的百分比。在重新同步的过程中，状态将是 `DEGRADED` ，当这个过程结束时将变为 `COMPLETE` 。"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:701
#, no-wrap
msgid "RAID3 - Byte-level Striping with Dedicated Parity"
msgstr "RAID3 - 带有专用奇偶校验的字节级条带"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:709
msgid ""
"RAID3 is a method used to combine several disk drives into a single volume with a dedicated parity disk.  In a RAID3 system, data is split up into a number of bytes that are "
"written across all the drives in the array except for one disk which acts as a dedicated parity disk.  This means that disk reads from a RAID3 implementation access all disks in "
"the array.  Performance can be enhanced by using multiple disk controllers.  The RAID3 array provides a fault tolerance of 1 drive, while providing a capacity of 1 - 1/n times "
"the total capacity of all drives in the array, where n is the number of hard drives in the array.  Such a configuration is mostly suitable for storing data of larger sizes such "
"as multimedia files."
msgstr ""
"RAID3 是一种用于将几个磁盘驱动器结合成一个具有专用奇偶校验盘的单一卷的方法。在一个 RAID3 系统中，数据被分割成若干字节，除了作为专用奇偶校验盘的一个磁盘外，这些字节被写入阵列中的"
"所有磁盘。这意味着，从一个 RAID3 实现中的磁盘读取会访问阵列中的所有磁盘。通过使用多个磁盘控制器可以提高性能。RAID3 阵列提供 1 个驱动器的容错，同时提供 1-1/n 倍于阵列中所有驱动器"
"总容量的容量，其中 n 是阵列中的硬盘数量。这样的配置大多适用于存储较大的数据，如多媒体文件。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:713
msgid ""
"At least 3 physical hard drives are required to build a RAID3 array.  Each disk must be of the same size, since I/O requests are interleaved to read or write to multiple disks "
"in parallel.  Also, due to the nature of RAID3, the number of drives must be equal to 3, 5, 9, 17, and so on, or 2^n + 1."
msgstr ""
"建立一个 RAID3 阵列，至少需要 3 个物理硬盘。每个磁盘必须是相同的大小，因为 I/O 请求是交错进行的，可以并行地读或写到多个磁盘。另外，由于 RAID3 的性质，硬盘的数量必须等于 3 、 "
"5 、 9 、 17 ，以此类推，或者 2^n+1 。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:715
msgid "This section demonstrates how to create a software RAID3 on a FreeBSD system."
msgstr "本节演示了如何在 FreeBSD 系统上创建一个软件 RAID3 。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:719
msgid "While it is theoretically possible to boot from a RAID3 array on FreeBSD, that configuration is uncommon and is not advised."
msgstr "虽然理论上可以从 FreeBSD 的 RAID3 阵列中启动，但这种配置并不常见，也不建议使用。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:721
#, no-wrap
msgid "Creating a Dedicated RAID3 Array"
msgstr "创建一个专用的RAID3阵列"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:725
msgid "In FreeBSD, support for RAID3 is implemented by the man:graid3[8] GEOM class.  Creating a dedicated RAID3 array on FreeBSD requires the following steps."
msgstr "在 FreeBSD 中，对 RAID3 的支持是由 man:graid3[8] GEOM 类实现的。在 FreeBSD 上创建一个专用的 RAID3 阵列需要以下步骤。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:728
msgid "First, load the [.filename]#geom_raid3.ko# kernel module by issuing one of the following commands:"
msgstr "加载 [.filename]#geom_raid3.ko# 模块"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:732
#, no-wrap
msgid "# graid3 load\n"
msgstr "# graid3 load\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:735
msgid "or:"
msgstr "或者"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:739
#, no-wrap
msgid "# kldload geom_raid3\n"
msgstr "# kldload geom_raid3\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:742
msgid "Ensure that a suitable mount point exists. This command creates a new directory to use as the mount point:"
msgstr "确保存在一个合适的挂载点。这条命令创建了一个新的目录，作为挂载点。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:746
#, no-wrap
msgid "# mkdir /multimedia\n"
msgstr "# mkdir /multimedia\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:749
msgid ""
"Determine the device names for the disks which will be added to the array, and create the new RAID3 device. The final device listed will act as the dedicated parity disk. This "
"example uses three unpartitioned ATA drives: [.filename]#ada1# and [.filename]#ada2# for data, and [.filename]#ada3# for parity."
msgstr ""
"确定将被添加到阵列中的磁盘的设备名称，并创建新的 RAID3 设备。最后列出的设备将作为专用的奇偶校验盘。这个例子使用了三个未分区的 ATA 硬盘：数据用 [.filename]#ada1# 和 "
"[.filename]#ada2# ，奇偶校验用 [.filename]#ada3# 。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:757
#, no-wrap
msgid ""
"# graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3\n"
"Metadata value stored on /dev/ada1.\n"
"Metadata value stored on /dev/ada2.\n"
"Metadata value stored on /dev/ada3.\n"
"Done.\n"
msgstr ""
"# graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3\n"
"Metadata value stored on /dev/ada1.\n"
"Metadata value stored on /dev/ada2.\n"
"Metadata value stored on /dev/ada3.\n"
"Done.\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:760
msgid "Partition the newly created [.filename]#gr0# device and put a UFS file system on it:"
msgstr "对新创建的 [.filename]#gr0# 设备进行分区，并在其上放置一个 UFS 文件系统。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:766
#, no-wrap
msgid ""
"# gpart create -s GPT /dev/raid3/gr0\n"
"# gpart add -t freebsd-ufs /dev/raid3/gr0\n"
"# newfs -j /dev/raid3/gr0p1\n"
msgstr ""
"# gpart create -s GPT /dev/raid3/gr0\n"
"# gpart add -t freebsd-ufs /dev/raid3/gr0\n"
"# newfs -j /dev/raid3/gr0p1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:770
msgid "Many numbers will glide across the screen, and after a bit of time, the process will be complete.  The volume has been created and is ready to be mounted:"
msgstr "许多数字会在屏幕上滑过，经过一段时间后，这个过程就完成了。卷已经被创建，并准备好被挂载。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:774
#, no-wrap
msgid "# mount /dev/raid3/gr0p1 /multimedia/\n"
msgstr "# mount /dev/raid3/gr0p1 /multimedia/\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:777
msgid "The RAID3 array is now ready to use."
msgstr "现在RAID3阵列已经可以使用了。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:779
msgid "Additional configuration is needed to retain this setup across system reboots."
msgstr "需要额外的配置，以便在系统重启时保留这一设置。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:782
msgid ""
"The [.filename]#geom_raid3.ko# module must be loaded before the array can be mounted. To automatically load the kernel module during system initialization, add the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr "[.filename]#geom_raid3.ko# 模块必须在阵列被挂载之前被加载。为了在系统初始化时自动加载内核模块，在 [.filename]#/boot/loader.conf# 中添加以下一行。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:786
#, no-wrap
msgid "geom_raid3_load=\"YES\"\n"
msgstr "geom_raid3_load=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:789
msgid "The following volume information must be added to [.filename]#/etc/fstab# in order to automatically mount the array's file system during the system boot process:"
msgstr "为了在系统启动过程中自动挂载阵列的文件系统，必须在 [.filename]#/etc/fstab# 中添加下列卷信息。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:793
#, no-wrap
msgid "/dev/raid3/gr0p1\t/multimedia\tufs\trw\t2\t2\n"
msgstr "/dev/raid3/gr0p1\t/multimedia\tufs\trw\t2\t2\n"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:796
#, no-wrap
msgid "Software RAID Devices"
msgstr "软件 RAID 设备"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:801
msgid ""
"Some motherboards and expansion cards add some simple hardware, usually just a ROM, that allows the computer to boot from a RAID array.  After booting, access to the RAID array "
"is handled by software running on the computer's main processor.  This \"hardware-assisted software RAID\" gives RAID arrays that are not dependent on any particular operating "
"system, and which are functional even before an operating system is loaded."
msgstr ""
"一些主板和扩展卡增加了一些简单的硬件，通常只是一个 ROM ，允许计算机从 RAID 阵列中启动。启动后，对 RAID 阵列的访问由运行在计算机主处理器上的软件处理。这种“硬件辅助的软件 RAID”使 "
"RAID 阵列不依赖于任何特定的操作系统，甚至在操作系统被加载之前就能发挥作用。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:804
msgid "Several levels of RAID are supported, depending on the hardware in use.  See man:graid[8] for a complete list."
msgstr "根据使用的硬件，支持几种级别的 RAID 。参见 man:graid[8] 以获得完整的列表。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:807
msgid ""
"man:graid[8] requires the [.filename]#geom_raid.ko# kernel module, which is included in the [.filename]#GENERIC# kernel starting with FreeBSD 9.1.  If needed, it can be loaded "
"manually with `graid load`."
msgstr "man:graid[8] 需要 [.filename]#geom_raid.ko# 内核模块，它从 FreeBSD 9.1 开始包含在 [.filename]#GENERIC# 内核中。如果需要，可以通过 `graid load` 手动加载。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:809
#, no-wrap
msgid "Creating an Array"
msgstr "创建一个阵列"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:814
msgid ""
"Software RAID devices often have a menu that can be entered by pressing special keys when the computer is booting.  The menu can be used to create and delete RAID arrays.  man:"
"graid[8] can also create arrays directly from the command line."
msgstr "软件 RAID 设备通常有一个菜单，可以在计算机启动时按下特殊键进入。该菜单可以用来创建和删除 RAID 阵列。graid(8) 也可以直接从命令行创建阵列。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:818
msgid ""
"`graid label` is used to create a new array.  The motherboard used for this example has an Intel software RAID chipset, so the Intel metadata format is specified.  The new array "
"is given a label of [.filename]#gm0#, it is a mirror (RAID1), and uses drives [.filename]#ada0# and [.filename]#ada1#."
msgstr ""
"`graid label` 用于创建一个新的阵列。本例中使用的主板有一个 Intel 软件 RAID 芯片组，所以指定了 Intel 元数据格式。新的阵列被赋予 [.filename]#gm0# 的标签，它是一个镜像（RAID1），并"
"且使用 [.filename]#ada0# 和 [.filename]#ada1# 硬盘。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:823
msgid "Some space on the drives will be overwritten when they are made into a new array.  Back up existing data first!"
msgstr "当硬盘被做成一个新的阵列时，硬盘上的一些空间将被覆盖。请先备份现有的数据！"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:837
#, no-wrap
msgid ""
"# graid label Intel gm0 RAID1 ada0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Array started.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.\n"
"Intel-a29ea104 created\n"
"GEOM_RAID: Intel-a29ea104: Provider raid/r0 for volume gm0 created.\n"
msgstr ""
"# graid label Intel gm0 RAID1 ada0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Array started.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.\n"
"Intel-a29ea104 created\n"
"GEOM_RAID: Intel-a29ea104: Provider raid/r0 for volume gm0 created.\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:840
msgid "A status check shows the new mirror is ready for use:"
msgstr "状态检查显示新的镜像已经可以使用了："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:847 content/zh-cn/books/handbook/geom/_index.adoc:1023
#, no-wrap
msgid ""
"# graid status\n"
"   Name   Status  Components\n"
"raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))\n"
"                  ada1 (ACTIVE (ACTIVE))\n"
msgstr ""
"# graid status\n"
"   Name   Status  Components\n"
"raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))\n"
"                  ada1 (ACTIVE (ACTIVE))\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:852
msgid ""
"The array device appears in [.filename]#/dev/raid/#.  The first array is called [.filename]#r0#.  Additional arrays, if present, will be [.filename]#r1#, [.filename]#r2#, and so "
"on."
msgstr "阵列设备出现在 [.filename]#/dev/raid/# 。第一个阵列被称为 [.filename]#r0# 。其他的阵列，如果存在的话，将是 [.filename]#r1# 、 [.filename]#r2# ，以此类推。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:856
msgid ""
"The BIOS menu on some of these devices can create arrays with special characters in their names.  To avoid problems with those special characters, arrays are given simple "
"numbered names like [.filename]#r0#.  To show the actual labels, like [.filename]#gm0# in the example above, use man:sysctl[8]:"
msgstr ""
"一些设备上的 BIOS 菜单可以创建名称中有特殊字符的阵列。为了避免这些特殊字符的问题，数组被赋予简单的编号名称，如 [.filename]#r0# 。要显示实际的标签，如上面例子中的 "
"[.filename]#gm0# ，请使用 man:sysctl[8]。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:860
#, no-wrap
msgid "# sysctl kern.geom.raid.name_format=1\n"
msgstr "# sysctl kern.geom.raid.name_format=1\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:863
#, no-wrap
msgid "Multiple Volumes"
msgstr "多卷"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:869
msgid ""
"Some software RAID devices support more than one _volume_ on an array.  Volumes work like partitions, allowing space on the physical drives to be split and used in different "
"ways.  For example, Intel software RAID devices support two volumes.  This example creates a 40 G mirror for safely storing the operating system, followed by a 20 G RAID0 "
"(stripe) volume for fast temporary storage:"
msgstr ""
"一些软件 RAID 设备支持在一个阵列上有一个以上的卷。卷的工作方式类似于分区，允许物理驱动器上的空间被分割并以不同方式使用。例如，英特尔软件 RAID 设备支持两个卷。这个例子创建了一个 "
"40G 的镜像，用于安全存储操作系统，然后是一个 20G 的 RAID0 （条带）卷，用于快速临时存储："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:874
#, no-wrap
msgid ""
"# graid label -S 40G Intel gm0 RAID1 ada0 ada1\n"
"# graid add -S 20G gm0 RAID0\n"
msgstr ""
"# graid label -S 40G Intel gm0 RAID1 ada0 ada1\n"
"# graid add -S 20G gm0 RAID0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:878
msgid "Volumes appear as additional [.filename]#rX# entries in [.filename]#/dev/raid/#.  An array with two volumes will show [.filename]#r0# and [.filename]#r1#."
msgstr "卷在 [.filename]#/dev/raid/# 中显示为额外的 [.filename]#rX# 条目。一个有两个卷的阵列将显示 [.filename]#r0# 和 [.filename]#r1# 。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:880
msgid "See man:graid[8] for the number of volumes supported by different software RAID devices."
msgstr "关于不同的软件 RAID 设备所支持的卷的数量，请参见 man:graid[8]。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:882
#, no-wrap
msgid "Converting a Single Drive to a Mirror"
msgstr "将单个驱动器转换为镜像"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:886
msgid ""
"Under certain specific conditions, it is possible to convert an existing single drive to a man:graid[8] array without reformatting.  To avoid data loss during the conversion, "
"the existing drive must meet these minimum requirements:"
msgstr "在某些特定的条件下，有可能将现有的单个硬盘转换成 man:graid[8] 阵列，而不需要重新格式化。为了避免转换过程中的数据丢失，现有的硬盘必须满足这些最低要求。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:888
msgid ""
"The drive must be partitioned with the MBR partitioning scheme. GPT or other partitioning schemes with metadata at the end of the drive will be overwritten and corrupted by the "
"man:graid[8] metadata."
msgstr "驱动器必须用 MBR 分区方案进行分区。GPT 或其他分区方案的元数据在硬盘的末端，会被 man:graid[8] 的元数据覆盖和破坏。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:889
msgid ""
"There must be enough unpartitioned and unused space at the end of the drive to hold the man:graid[8] metadata. This metadata varies in size, but the largest occupies 64 M, so at "
"least that much free space is recommended."
msgstr "驱动器末端必须有足够的未分区和未使用的空间来容纳 man:graid[8] 元数据。这个元数据的大小各不相同，但最大的占据了 64M ，所以建议至少有这么多的可用空间。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:892
msgid "If the drive meets these requirements, start by making a full backup.  Then create a single-drive mirror with that drive:"
msgstr "如果驱动器满足这些要求，则首先进行完全备份。然后用这个驱动器创建一个单驱动器镜像:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:896
#, no-wrap
msgid "# graid label Intel gm0 RAID1 ada0 NONE\n"
msgstr "# graid label Intel gm0 RAID1 ada0 NONE\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:900
msgid "man:graid[8] metadata was written to the end of the drive in the unused space.  A second drive can now be inserted into the mirror:"
msgstr "man:graid[8] 元数据被写到驱动器末端的未使用空间中。现在可以在镜像中插入第二个驱动器："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:904
#, no-wrap
msgid "# graid insert raid/r0 ada1\n"
msgstr "# graid insert raid/r0 ada1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:908
msgid "Data from the original drive will immediately begin to be copied to the second drive.  The mirror will operate in degraded status until the copy is complete."
msgstr "原始硬盘的数据将立即开始复制到第二个硬盘。镜像将以降级状态运行，直到复制完成。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:910
#, no-wrap
msgid "Inserting New Drives into the Array"
msgstr "将新的硬盘插入阵列中"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:915
msgid ""
"Drives can be inserted into an array as replacements for drives that have failed or are missing.  If there are no failed or missing drives, the new drive becomes a spare.  For "
"example, inserting a new drive into a working two-drive mirror results in a two-drive mirror with one spare drive, not a three-drive mirror."
msgstr ""
"驱动器可以被插入到阵列中，作为故障或丢失的驱动器的替代。如果没有故障或丢失的驱动器，新的驱动器就成为备用驱动器。例如，将一个新的驱动器插入到一个工作的双驱动器镜像中，结果是一个有"
"一个备用驱动器的双驱动器镜像，而不是一个三驱动器的镜像。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:918
msgid "In the example mirror array, data immediately begins to be copied to the newly-inserted drive.  Any existing information on the new drive will be overwritten."
msgstr "在这个例子的镜像阵列中，数据立即开始被复制到新插入的硬盘。新驱动器上的任何现有信息将被覆盖："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:926
#, no-wrap
msgid ""
"# graid insert raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.\n"
msgstr ""
"# graid insert raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:929
#, no-wrap
msgid "Removing Drives from the Array"
msgstr "从阵列中移除硬盘"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:932
msgid "Individual drives can be permanently removed from a from an array and their metadata erased:"
msgstr "单个驱动器可以从一个阵列中永久移除，其元数据也被删除："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:939
#, no-wrap
msgid ""
"# graid remove raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.\n"
msgstr ""
"# graid remove raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:942
#, no-wrap
msgid "Stopping the Array"
msgstr "停止阵列"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:946
msgid "An array can be stopped without removing metadata from the drives.  The array will be restarted when the system is booted."
msgstr "阵列可以被停止，而不需要从驱动器上删除元数据。当系统被启动时，该阵列将被重新启动："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:950
#, no-wrap
msgid "# graid stop raid/r0\n"
msgstr "# graid stop raid/r0\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:953
#, no-wrap
msgid "Checking Array Status"
msgstr "检查阵列状态"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:957
msgid "Array status can be checked at any time.  After a drive was added to the mirror in the example above, data is being copied from the original drive to the new drive:"
msgstr "阵列状态可以在任何时候检查。在上面的例子中，一个驱动器被添加到镜像中后，数据正从原来的驱动器复制到新的驱动器上："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:964
#, no-wrap
msgid ""
"# graid status\n"
"   Name    Status  Components\n"
"raid/r0  DEGRADED  ada0 (ACTIVE (ACTIVE))\n"
"                   ada1 (ACTIVE (REBUILD 28%))\n"
msgstr ""
"# graid status\n"
"   Name    Status  Components\n"
"raid/r0  DEGRADED  ada0 (ACTIVE (ACTIVE))\n"
"                   ada1 (ACTIVE (REBUILD 28%))\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:968
msgid "Some types of arrays, like `RAID0` or `CONCAT`, may not be shown in the status report if disks have failed.  To see these partially-failed arrays, add `-ga`:"
msgstr "某些类型的阵列，比如 `RAID0` 或 `CONCAT` ，如果磁盘发生故障，可能不会显示在状态报告中。要看到这些部分失败的阵列，请添加 `-ga`："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:974
#, no-wrap
msgid ""
"# graid status -ga\n"
"          Name  Status  Components\n"
"Intel-e2d07d9a  BROKEN  ada6 (ACTIVE (ACTIVE))\n"
msgstr ""
"# graid status -ga\n"
"          Name  Status  Components\n"
"Intel-e2d07d9a  BROKEN  ada6 (ACTIVE (ACTIVE))\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:977
#, no-wrap
msgid "Deleting Arrays"
msgstr "删除阵列"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:981
msgid "Arrays are destroyed by deleting all of the volumes from them.  When the last volume present is deleted, the array is stopped and metadata is removed from the drives:"
msgstr "阵列是通过删除其中所有的卷来销毁的。当最后一个卷被删除时，阵列被停止，元数据从驱动器上被删除："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:985 content/zh-cn/books/handbook/geom/_index.adoc:1030
#, no-wrap
msgid "# graid delete raid/r0\n"
msgstr "# graid delete raid/r0\n"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:988
#, no-wrap
msgid "Deleting Unexpected Arrays"
msgstr "删除意外的阵列"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:993
msgid ""
"Drives may unexpectedly contain man:graid[8] metadata, either from previous use or manufacturer testing.  man:graid[8] will detect these drives and create an array, interfering "
"with access to the individual drive.  To remove the unwanted metadata:"
msgstr "驱动器可能意外地包含 man:graid[8] 元数据，可能是以前的使用或制造商的测试。man:graid[8] 会检测到这些驱动器并创建一个阵列，干扰对单个驱动器的访问。要删除不需要的元数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:996
msgid "Boot the system. At the boot menu, select `2` for the loader prompt. Enter:"
msgstr "启动系统。在启动菜单上，选择 `2` 为加载器提示。输入:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1001
#, no-wrap
msgid ""
"OK set kern.geom.raid.enable=0\n"
"OK boot\n"
msgstr ""
"OK set kern.geom.raid.enable=0\n"
"OK boot\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1004
msgid "The system will boot with man:graid[8] disabled."
msgstr "系统将在禁用 man:graid[8] 的情况下启动。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1005
msgid "Back up all data on the affected drive."
msgstr "备份受影响驱动器上的所有数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1006
msgid "As a workaround, man:graid[8] array detection can be disabled by adding"
msgstr "作为一种变通方法，可以通过添加以下内容禁用 man:graid[8] 阵列检测:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1010
#, no-wrap
msgid "kern.geom.raid.enable=0\n"
msgstr "kern.geom.raid.enable=0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1013
msgid "to [.filename]#/boot/loader.conf#."
msgstr "到 [.filename]#/boot/loader.conf#。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1016
msgid ""
"To permanently remove the man:graid[8] metadata from the affected drive, boot a FreeBSD installation CD-ROM or memory stick, and select `Shell`.  Use `status` to find the name "
"of the array, typically `raid/r0`:"
msgstr "要从受影响的驱动器中永久删除 man:graid[8] 元数据，请启动 FreeBSD 安装光盘或记忆棒，并选择 `Shell`。使用 `status` 找到阵列的名称，通常是 `raid/r0`："

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1026
msgid "Delete the volume by name:"
msgstr "按名称删除卷。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1034
msgid "If there is more than one volume shown, repeat the process for each volume.  After the last array has been deleted, the volume will be destroyed."
msgstr "如果显示有多个卷，对每个卷重复该过程。在最后一个阵列被删除后，卷将被销毁。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1037
msgid ""
"Reboot and verify data, restoring from backup if necessary.  After the metadata has been removed, the `kern.geom.raid.enable=0` entry in [.filename]#/boot/loader.conf# can also "
"be removed."
msgstr "重新启动并验证数据，必要时从备份中恢复。在删除元数据后，也可以删除 [.filename]#/boot/loader.conf# 中的 `kern.geom.raid.enable=0` 条目。"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:1039
#, no-wrap
msgid "GEOM Gate Network"
msgstr "GEOM Gate 网络设备"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1044
msgid ""
"GEOM provides a simple mechanism for providing remote access to devices such as disks, CDs, and file systems through the use of the GEOM Gate network daemon, ggated.  The system "
"with the device runs the server daemon which handles requests made by clients using ggatec.  The devices should not contain any sensitive data as the connection between the "
"client and the server is not encrypted."
msgstr ""
"GEOM 提供了一种简单的机制，通过使用 GEOM Gate 网络守护程序 ggated ，提供对磁盘、 CD 和文件系统等设备的远程访问。拥有设备的系统运行服务器守护程序，处理客户使用 ggatec 提出的请求。"
"这些设备不应包含任何敏感数据，因为客户端和服务器之间的连接没有加密。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1048
msgid ""
"Similar to NFS, which is discussed in crossref:network-servers[network-nfs,\"Network File System (NFS)\"], ggated is configured using an exports file.  This file specifies which "
"systems are permitted to access the exported resources and what level of access they are offered.  For example, to give the client `192.168.1.5` read and write access to the "
"fourth slice on the first SCSI disk, create [.filename]#/etc/gg.exports# with this line:"
msgstr ""
"与 crossref:network-servers[network-nfs,网络文件系统（NFS）] 中讨论的 NFS 类似，ggated 也是通过一个出口文件来配置的。这个文件指定了哪些系统被允许访问导出的资源，以及提供给他们的"
"访问级别。例如，为了让客户端 `192.168.1.5` 读写第一个 SCSI 磁盘上的第四个片断，用这一行创建 [.filename]#/etc/gg.exports#："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1052
#, no-wrap
msgid "192.168.1.5 RW /dev/da0s4d\n"
msgstr "192.168.1.5 RW /dev/da0s4d\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1056
msgid "Before exporting the device, ensure it is not currently mounted.  Then, start ggated:"
msgstr "在导出设备之前，确保它目前没有被挂载。然后，启动 ggated："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1060
#, no-wrap
msgid "# ggated\n"
msgstr "# ggated\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1064
msgid "Several options are available for specifying an alternate listening port or changing the default location of the exports file.  Refer to man:ggated[8] for details."
msgstr "有几个选项可以用来指定一个备用的监听端口或改变出口文件的默认位置。详情请参考 man:ggated[8]。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1069
msgid ""
"To access the exported device on the client machine, first use `ggatec` to specify the IP address of the server and the device name of the exported device.  If successful, this "
"command will display a `ggate` device name to mount.  Mount that specified device name on a free mount point.  This example connects to the [.filename]#/dev/da0s4d# partition on "
"`192.168.1.1`, then mounts [.filename]#/dev/ggate0# on [.filename]#/mnt#:"
msgstr ""
"要在客户机上访问导出的设备，首先使用 `ggatec` 来指定服务器的 IP 地址和导出设备的设备名。如果成功，这个命令将显示一个要挂载的 `ggate` 设备名。在一个空闲的挂载点上挂载那个指定的设"
"备名。这个例子连接到 `192.168.1.1` 上的 [.filename]#/dev/da0s4d# 分区，然后将 [.filename]#/dev/ggate0# 挂载到 [.filename]#/mnt#："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1075
#, no-wrap
msgid ""
"# ggatec create -o rw 192.168.1.1 /dev/da0s4d\n"
"ggate0\n"
"# mount /dev/ggate0 /mnt\n"
msgstr ""
"# ggatec create -o rw 192.168.1.1 /dev/da0s4d\n"
"ggate0\n"
"# mount /dev/ggate0 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1079
msgid "The device on the server may now be accessed through [.filename]#/mnt# on the client.  For more details about `ggatec` and a few usage examples, refer to man:ggatec[8]."
msgstr "现在可以通过客户端的 [.filename]#/mnt# 访问服务器上的设备。关于 `ggatec` 的更多细节和一些使用例子，请参考 man:ggatec[8]。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1084
msgid ""
"The mount will fail if the device is currently mounted on either the server or any other client on the network.  If simultaneous access is needed to network resources, use NFS "
"instead."
msgstr "如果该设备目前被挂载在服务器或网络上的任何其他客户端上，挂载将失败。如果需要同时访问网络资源，请使用 NFS 代替。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1087
msgid "When the device is no longer needed, unmount it with `umount` so that the resource is available to other clients."
msgstr "当不再需要该设备时，用 `umount` 卸载它，这样该资源就可以供其他客户使用。"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:1089
#, no-wrap
msgid "Labeling Disk Devices"
msgstr "为磁盘设备添加卷标"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1095
msgid ""
"During system initialization, the FreeBSD kernel creates device nodes as devices are found.  This method of probing for devices raises some issues.  For instance, what if a new "
"disk device is added via USB? It is likely that a flash device may be handed the device name of [.filename]#da0# and the original [.filename]#da0# shifted to [.filename]#da1#.  "
"This will cause issues mounting file systems if they are listed in [.filename]#/etc/fstab# which may also prevent the system from booting."
msgstr ""
"在系统初始化过程中，FreeBSD 内核会在发现设备时创建设备节点。这种探测设备的方法引起了一些问题。例如，如果一个新的磁盘设备是通过 USB 添加的呢？很可能一个闪存设备会被赋予 "
"[.filename]#da0# 的设备名，而原来的 [.filename]#da0# 则被转移到 [.filename]#da1# 。如果文件系统被列在 [.filename]#/etc/fstab# 中，这将导致文件系统的挂载问题，也可能导致系统无法启"
"动。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1100
msgid ""
"One solution is to chain SCSI devices in order so a new device added to the SCSI card will be issued unused device numbers.  But what about USB devices which may replace the "
"primary SCSI disk? This happens because USB devices are usually probed before the SCSI card.  One solution is to only insert these devices after the system has been booted.  "
"Another method is to use only a single ATA drive and never list the SCSI devices in [.filename]#/etc/fstab#."
msgstr ""
"一个解决方案是按顺序连锁 SCSI 设备，这样添加到 SCSI 卡上的新设备就会被发放未使用的设备号。但是，USB 设备可能会取代主 SCSI 磁盘呢？发生这种情况是因为 USB 设备通常在 SCSI 卡之前被"
"探测到。一种解决办法是只在系统启动后插入这些设备。另一个方法是只使用单一的 ATA 驱动器，并且从不在 [.filename]#/etc/fstab# 中列出 SCSI 设备。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1104
msgid ""
"A better solution is to use `glabel` to label the disk devices and use the labels in [.filename]#/etc/fstab#.  Since `glabel` stores the label in the last sector of a given "
"provider, the label will remain persistent across reboots.  By using this label as a device, the file-system may always be mounted regardless of what device node it is accessed "
"through."
msgstr ""
"一个更好的解决方案是使用 `glabel` 来标记磁盘设备，并在 [.filename]#/etc/fstab# 中使用这些标签。由于 `glabel` 将标签存储在给定供应者的最后一个扇区中，标签将在重启时保持持久性。通"
"过使用这个标签作为设备，文件系统可以始终被挂载，无论它是通过什么设备节点被访问的。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1109
msgid ""
"`glabel` can create both transient and permanent labels. Only permanent labels are consistent across reboots.  Refer to man:glabel[8] for more information on the differences "
"between labels."
msgstr "`glabel` 可以创建暂时性和永久性的标签。只有永久标签在重启时是一致的。请参考 man:glabel[8] 了解更多关于标签之间区别的信息。"

#. type: Title ===
#: content/zh-cn/books/handbook/geom/_index.adoc:1111
#, no-wrap
msgid "Label Types and Examples"
msgstr "标签类型和例子"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1119
msgid ""
"Permanent labels can be a generic or a file system label.  Permanent file system labels can be created with man:tunefs[8] or man:newfs[8].  These types of labels are created in "
"a sub-directory of [.filename]#/dev#, and will be named according to the file system type.  For example, UFS2 file system labels will be created in [.filename]#/dev/ufs#.  "
"Generic permanent labels can be created with `glabel label`.  These are not file system specific and will be created in [.filename]#/dev/label#."
msgstr ""
"永久标签可以是一个通用标签或一个文件系统标签。永久文件系统标签可以用 man:tunefs[8] 或 man:newfs[8] 创建。这些类型的标签被创建在 [.filename]#/dev# 的一个子目录下，并将根据文件系统"
"的类型来命名。例如，UFS2 文件系统的标签将在 [.filename]#/dev/ufs# 中创建。通用的永久标签可以用 `glabel label` 创建。这些标签不针对文件系统，将被创建在 [.filename]#/dev/label# "
"中。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1123
msgid ""
"Temporary labels are destroyed at the next reboot.  These labels are created in [.filename]#/dev/label# and are suited to experimentation.  A temporary label can be created "
"using `glabel create`."
msgstr "临时标签在下次重启时被销毁。这些标签是在 [.filename]#/dev/label# 中创建的，适合于实验。可以使用 `glabel create` 来创建一个临时标签。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1125
msgid "To create a permanent label for a UFS2 file system without destroying any data, issue the following command:"
msgstr "要为 UFS2 文件系统创建一个永久标签而不破坏任何数据，请发出以下命令。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1129
#, no-wrap
msgid "# tunefs -L home /dev/da3\n"
msgstr "# tunefs -L home /dev/da3\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1132
msgid "A label should now exist in [.filename]#/dev/ufs# which may be added to [.filename]#/etc/fstab#:"
msgstr "现在 [.filename]#/dev/ufs# 中应该有一个标签，可以添加到 [.filename]#/etc/fstab# 中。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1136
#, no-wrap
msgid "/dev/ufs/home\t\t/home            ufs     rw              2      2\n"
msgstr "/dev/ufs/home\t\t/home            ufs     rw              2      2\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1141
msgid "The file system must not be mounted while attempting to run `tunefs`."
msgstr "在试图运行 tunefs 时，文件系统不能被挂载。现在可以挂载文件系统"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1144
msgid "Now the file system may be mounted:"
msgstr "现在可以挂载文件系统了:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1148
#, no-wrap
msgid "# mount /home\n"
msgstr "# mount /home\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1151
msgid ""
"From this point on, so long as the [.filename]#geom_label.ko# kernel module is loaded at boot with [.filename]#/boot/loader.conf# or the `GEOM_LABEL` kernel option is present, "
"the device node may change without any ill effect on the system."
msgstr ""
"从这时起，只要在启动时用 [.filename]#/boot/loader.conf# 加载 [.filename]#geom_label.ko# 内核模块，或者存在 `GEOM_LABEL` 内核选项，设备节点就可以改变而不会对系统产生任何不良影响。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1154
msgid "File systems may also be created with a default label by using the `-L` flag with `newfs`.  Refer to man:newfs[8] for more information."
msgstr "文件系统也可以通过使用 `newfs` 的 `-L` 标志来创建一个默认的标签。更多信息请参考 man:newfs[8]。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1156
msgid "The following command can be used to destroy the label:"
msgstr "下面的命令可以用来销毁标签。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1160
#, no-wrap
msgid "# glabel destroy home\n"
msgstr "# glabel destroy home\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1163
msgid "The following example shows how to label the partitions of a boot disk."
msgstr "下面的例子显示了如何给启动盘的分区贴标签。"

#. type: Block title
#: content/zh-cn/books/handbook/geom/_index.adoc:1164
#, no-wrap
msgid "Labeling Partitions on the Boot Disk"
msgstr "给启动盘上的分区贴标签"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1170
msgid ""
"By permanently labeling the partitions on the boot disk, the system should be able to continue to boot normally, even if the disk is moved to another controller or transferred "
"to a different system.  For this example, it is assumed that a single ATA disk is used, which is currently recognized by the system as [.filename]#ad0#.  It is also assumed that "
"the standard FreeBSD partition scheme is used, with [.filename]#/#, [.filename]#/var#, [.filename]#/usr# and [.filename]#/tmp#, as well as a swap partition."
msgstr ""
"通过对启动盘上的分区进行永久标记，系统应该能够继续正常启动，即使磁盘被移到另一个控制器上或者被转移到不同的系统。在这个例子中，假设使用的是一个 ATA 磁盘，目前系统识别为 "
"[.filename]#ad0# 。还假设使用了标准的 FreeBSD 分区方案，包括 [.filename]#/#、 [.filename]#/var#、 [.filename]#/usr# 和 [.filename]#/tmp# ，以及一个交换分区。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1173
msgid "Reboot the system, and at the man:loader[8] prompt, press kbd:[4] to boot into single user mode.  Then enter the following commands:"
msgstr "重新启动系统，在 man:loader[8] 提示下，按 kbd:[4] 键启动到单用户模式。然后输入以下命令。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1187
#, no-wrap
msgid ""
"# glabel label rootfs /dev/ad0s1a\n"
"GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs\n"
"# glabel label var /dev/ad0s1d\n"
"GEOM_LABEL: Label for provider /dev/ad0s1d is label/var\n"
"# glabel label usr /dev/ad0s1f\n"
"GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr\n"
"# glabel label tmp /dev/ad0s1e\n"
"GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp\n"
"# glabel label swap /dev/ad0s1b\n"
"GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap\n"
"# exit\n"
msgstr ""
"# glabel label rootfs /dev/ad0s1a\n"
"GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs\n"
"# glabel label var /dev/ad0s1d\n"
"GEOM_LABEL: Label for provider /dev/ad0s1d is label/var\n"
"# glabel label usr /dev/ad0s1f\n"
"GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr\n"
"# glabel label tmp /dev/ad0s1e\n"
"GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp\n"
"# glabel label swap /dev/ad0s1b\n"
"GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap\n"
"# exit\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1192
msgid ""
"The system will continue with multi-user boot.  After the boot completes, edit [.filename]#/etc/fstab# and replace the conventional device names, with their respective labels.  "
"The final [.filename]#/etc/fstab# will look like this:"
msgstr "系统将继续以多用户启动。启动完成后，编辑 [.filename]#/etc/fstab# ，用各自的标签替换传统的设备名称。最后的 [.filename]#/etc/fstab# 将看起来像这样。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1201
#, no-wrap
msgid ""
"# Device                Mountpoint      FStype  Options         Dump    Pass#\n"
"/dev/label/swap         none            swap    sw              0       0\n"
"/dev/label/rootfs       /               ufs     rw              1       1\n"
"/dev/label/tmp          /tmp            ufs     rw              2       2\n"
"/dev/label/usr          /usr            ufs     rw              2       2\n"
"/dev/label/var          /var            ufs     rw              2       2\n"
msgstr ""
"# Device                Mountpoint      FStype  Options         Dump    Pass#\n"
"/dev/label/swap         none            swap    sw              0       0\n"
"/dev/label/rootfs       /               ufs     rw              1       1\n"
"/dev/label/tmp          /tmp            ufs     rw              2       2\n"
"/dev/label/usr          /usr            ufs     rw              2       2\n"
"/dev/label/var          /var            ufs     rw              2       2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1205
msgid "The system can now be rebooted.  If everything went well, it will come up normally and `mount` will show:"
msgstr "现在可以重新启动系统了。如果一切顺利，它将正常出现，并显示挂载。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1214
#, no-wrap
msgid ""
"# mount\n"
"/dev/label/rootfs on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/label/tmp on /tmp (ufs, local, soft-updates)\n"
"/dev/label/usr on /usr (ufs, local, soft-updates)\n"
"/dev/label/var on /var (ufs, local, soft-updates)\n"
msgstr ""
"# mount\n"
"/dev/label/rootfs on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/label/tmp on /tmp (ufs, local, soft-updates)\n"
"/dev/label/usr on /usr (ufs, local, soft-updates)\n"
"/dev/label/var on /var (ufs, local, soft-updates)\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1222
msgid ""
"The man:glabel[8] class supports a label type for UFS file systems, based on the unique file system id, `ufsid`.  These labels may be found in [.filename]#/dev/ufsid# and are "
"created automatically during system startup.  It is possible to use `ufsid` labels to mount partitions using [.filename]#/etc/fstab#.  Use `glabel status` to receive a list of "
"file systems and their corresponding `ufsid` labels:"
msgstr ""
"man:glabel[8] 类支持 UFS 文件系统的标签类型，基于唯一的文件系统标识 `ufsid`。这些标签可以在 [.filename]#/dev/ufsid# 中找到，并在系统启动时自动创建。使用 [.filename]#/etc/fstab# "
"可以使用 `ufsid` 标签来装载分区。使用 `glabel status` 来接收文件系统和它们相应的 `ufsid` 标签的列表:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1229
#, no-wrap
msgid ""
"% glabel status\n"
"                  Name  Status  Components\n"
"ufsid/486b6fc38d330916     N/A  ad4s1d\n"
"ufsid/486b6fc16926168e     N/A  ad4s1f\n"
msgstr ""
"% glabel status\n"
"                  Name  Status  Components\n"
"ufsid/486b6fc38d330916     N/A  ad4s1d\n"
"ufsid/486b6fc16926168e     N/A  ad4s1f\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1233
msgid ""
"In the above example, [.filename]#ad4s1d# represents [.filename]#/var#, while [.filename]#ad4s1f# represents [.filename]#/usr#.  Using the `ufsid` values shown, these partitions "
"may now be mounted with the following entries in [.filename]#/etc/fstab#:"
msgstr ""
"在上述例子中， [.filename]#ad4s1d# 代表 [.filename]#/var# ，而 [.filename]#ad4s1f# 代表 [.filename]#/usr# 。使用所示的 `ufsid` 值，这些分区现在可以用 [.filename]#/etc/fstab# 中的"
"以下条目来挂载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1238
#, no-wrap
msgid ""
"/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2\n"
"/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2\n"
msgstr ""
"/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2\n"
"/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1241
msgid ""
"Any partitions with `ufsid` labels can be mounted in this way, eliminating the need to manually create permanent labels, while still enjoying the benefits of device name "
"independent mounting."
msgstr "任何带有 `ufsid` 标签的分区都可以用这种方式挂载，不需要手动创建永久标签，同时还可以享受设备名称独立挂载的好处。"

#. type: Title ==
#: content/zh-cn/books/handbook/geom/_index.adoc:1243
#, no-wrap
msgid "UFS Journaling Through GEOM"
msgstr "通过 GEOM 实现 UFS 日志"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1249
msgid ""
"Support for journals on UFS file systems is available on FreeBSD.  The implementation is provided through the GEOM subsystem and is configured using `gjournal`.  Unlike other "
"file system journaling implementations, the `gjournal` method is block based and not implemented as part of the file system.  It is a GEOM extension."
msgstr ""
"在 FreeBSD 上，对 UFS 文件系统的日志支持是可用的。这个实现是通过 GEOM 子系统提供的，并通过 `gjournal` 进行配置。与其他文件系统的日志实现不同，`gjournal` 方法是基于块的，而不是作"
"为文件系统的一部分来实现。它是一个 GEOM 扩展。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1252
msgid ""
"Journaling stores a log of file system transactions, such as changes that make up a complete disk write operation, before meta-data and file writes are committed to the disk.  "
"This transaction log can later be replayed to redo file system transactions, preventing file system inconsistencies."
msgstr "在元数据和文件写入提交到磁盘之前，日志存储了文件系统事务的日志，例如构成一个完整磁盘写入操作的变化。这个事务日志以后可以重放，重做文件系统事务，防止文件系统的不一致。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1257
msgid ""
"This method provides another mechanism to protect against data loss and inconsistencies of the file system.  Unlike Soft Updates, which tracks and enforces meta-data updates, "
"and snapshots, which create an image of the file system, a log is stored in disk space specifically for this task.  For better performance, the journal may be stored on another "
"disk.  In this configuration, the journal provider or storage device should be listed after the device to enable journaling on."
msgstr ""
"这种方法提供了另一种机制来防止数据丢失和文件系统的不一致。与跟踪和执行元数据更新的软更新和创建文件系统图像的快照不同，日志是专门为这项任务存储在磁盘空间的。为了提高性能，日志可以"
"存储在另一个磁盘上。在这种配置中，日志提供者或存储设备应该列在要启用日志的设备之后。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1260
msgid ""
"The [.filename]#GENERIC# kernel provides support for `gjournal`.  To automatically load the [.filename]#geom_journal.ko# kernel module at boot time, add the following line to [."
"filename]#/boot/loader.conf#:"
msgstr "[.filename]#GENERIC# 内核提供了对 `gjournal` 的支持。要在启动时自动加载 [.filename]#geom_journal.ko# 内核模块，请在 [.filename]#/boot/loader.conf# 中加入以下一行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1264
#, no-wrap
msgid "geom_journal_load=\"YES\"\n"
msgstr "geom_journal_load=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1267
msgid "If a custom kernel is used, ensure the following line is in the kernel configuration file:"
msgstr "如果使用自定义的内核，确保在内核配置文件中有以下一行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1271
#, no-wrap
msgid "options\tGEOM_JOURNAL\n"
msgstr "options\tGEOM_JOURNAL\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1275
msgid "Once the module is loaded, a journal can be created on a new file system using the following steps.  In this example, [.filename]#da4# is a new SCSI disk:"
msgstr "加载该模块之后，就可以通过以下步骤在新的文件系统上创建一个日志。在这个例子中，[.filename]#da4# 是一个新的 SCSI 磁盘："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1280
#, no-wrap
msgid ""
"# gjournal load\n"
"# gjournal label /dev/da4\n"
msgstr ""
"# gjournal load\n"
"# gjournal label /dev/da4\n"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1283
msgid "This will load the module and create a [.filename]#/dev/da4.journal# device node on [.filename]#/dev/da4#."
msgstr "这将加载该模块并在 [.filename]#/dev/da4# 上创建一个 [.filename]#/dev/da4.journal# 设备节点。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1285
msgid "A UFS file system may now be created on the journaled device, then mounted on an existing mount point:"
msgstr "现在可以在该日志设备上创建一个 UFS 文件系统，然后挂载到一个现有的挂载点。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1290
#, no-wrap
msgid ""
"# newfs -O 2 -J /dev/da4.journal\n"
"# mount /dev/da4.journal /mnt\n"
msgstr ""
"# newfs -O 2 -J /dev/da4.journal\n"
"# mount /dev/da4.journal /mnt\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/geom/_index.adoc:1296
msgid ""
"In the case of several slices, a journal will be created for each individual slice.  For instance, if [.filename]#ad4s1# and [.filename]#ad4s2# are both slices, then `gjournal` "
"will create [.filename]#ad4s1.journal# and [.filename]#ad4s2.journal#."
msgstr ""
"如果有多个片断，则为每个片断创建一个日志。例如，如果 [.filename]#ad4s1# 和 [.filename]#ad4s2# 都是片段，那么 `gjournal` 就会创建 [.filename]#ad4s1.journal# 和 "
"[.filename]#ad4s2.journal#。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1302
msgid ""
"Journaling may also be enabled on current file systems by using `tunefs`.  However, _always_ make a backup before attempting to alter an existing file system.  In most cases, "
"`gjournal` will fail if it is unable to create the journal, but this does not protect against data loss incurred as a result of misusing `tunefs`.  Refer to man:gjournal[8] and "
"man:tunefs[8] for more information about these commands."
msgstr ""
"也可以通过使用 `tunefs` 在当前的文件系统上启用日志功能。不过，在尝试改变现有文件系统之前，一定要先做备份。在大多数情况下，如果 `gjournal` 无法创建日志，它就会失败，但这并不能防止"
"因误用 `tunefs` 而导致的数据丢失。关于这些命令的更多信息，请参考 man:gjournal[8] 和 man:tunefs[8] 。"

#. type: Plain text
#: content/zh-cn/books/handbook/geom/_index.adoc:1304
msgid ""
"It is possible to journal the boot disk of a FreeBSD system.  Refer to the article extref:{gjournal-desktop}[Implementing UFS Journaling on a Desktop PC] for detailed "
"instructions."
msgstr ""
