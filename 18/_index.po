# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2022-03-11 21:39+0800\n"
"PO-Revision-Date: 2022-04-05 12:24+0800\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#. type: YAML Front Matter: description
#: content/zh-cn/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "This chapter covers the use of disks and storage media in FreeBSD. This includes SCSI and IDE disks, CD and DVD media, memory-backed disks, and USB storage devices."
msgstr "这一章介绍了 FreeBSD 中磁盘和存储介质的使用。这包括 SCSI 和 IDE 磁盘、CD 和 DVD 介质、内存支持的磁盘以及 USB 存储设备。"

#. type: YAML Front Matter: part
#: content/zh-cn/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "第三部分 系统管理"

#. type: YAML Front Matter: title
#: content/zh-cn/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "Chapter 18. Storage"
msgstr "第18章 存储"

#. type: Title =
#: content/zh-cn/books/handbook/disks/_index.adoc:14
#, no-wrap
msgid "Storage"
msgstr "存储"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "概述"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:56
msgid ""
"This chapter covers the use of disks and storage media in FreeBSD.  This includes SCSI and IDE disks, CD and DVD media, memory-backed disks, and USB storage devices."
msgstr "这一章介绍了 FreeBSD 中磁盘和存储介质的使用。这包括 SCSI 和 IDE 磁盘、CD 和 DVD 介质、内存支持的磁盘以及 USB 存储设备。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:58
msgid "After reading this chapter, you will know:"
msgstr "读完本章后，你会了解："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:60
msgid "How to add additional hard disks to a FreeBSD system."
msgstr "如何在 FreeBSD 系统中添加额外的硬盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:61
msgid "How to grow the size of a disk's partition on FreeBSD."
msgstr "如何在 FreeBSD 上增加一个磁盘的分区大小。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:62
msgid "How to configure FreeBSD to use USB storage devices."
msgstr "如何配置 FreeBSD 来使用 USB 存储设备。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:63
msgid "How to use CD and DVD media on a FreeBSD system."
msgstr "如何在 FreeBSD 系统中使用 CD 和 DVD 介质。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:64
msgid "How to use the backup programs available under FreeBSD."
msgstr "如何使用 FreeBSD 下可用的备份程序。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:65
msgid "How to set up memory disks."
msgstr "如何设置内存磁盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:66
msgid "What file system snapshots are and how to use them efficiently."
msgstr "什么是文件系统快照以及如何有效地使用它们。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:67
msgid "How to use quotas to limit disk space usage."
msgstr "如何使用配额制来限制磁盘空间的使用。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:68
msgid "How to encrypt disks and swap to secure them against attackers."
msgstr "如何对磁盘和交换进行加密以防止攻击者。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:69
msgid "How to configure a highly available storage network."
msgstr "如何配置一个高可用性存储网络。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:71
msgid "Before reading this chapter, you should:"
msgstr "在阅读本章之前，你应该："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:73
msgid "Know how to crossref:kernelconfig[kernelconfig,configure and install a new FreeBSD kernel]."
msgstr "知道如何配置和安装一个新的 FreeBSD 内核。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:75
#, no-wrap
msgid "Adding Disks"
msgstr "添加磁盘"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:80
msgid ""
"This section describes how to add a new SATA disk to a machine that currently only has a single drive.  First, turn off the computer and install the drive in the "
"computer following the instructions of the computer, controller, and drive manufacturers.  Reboot the system and become `root`."
msgstr ""
"本节介绍如何在目前只有一个驱动器的机器上添加一个新的 SATA 磁盘。首先，关闭计算机，按照计算机、控制器和驱动器制造商的说明将驱动器安装到计算机中。重新启动系统并切换到 root "
"用户。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:83
msgid "Inspect [.filename]#/var/run/dmesg.boot# to ensure the new disk was found.  In this example, the newly added SATA drive will appear as [.filename]#ada1#."
msgstr "检查 [.filename]#/var/run/dmesg.boot# 以确保新的磁盘被找到。在这个例子中，新增加的 SATA 驱动器显示为 [.filename]#ada1#。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:86
msgid ""
"For this example, a single large partition will be created on the new disk.  The http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] partitioning scheme will be used "
"in preference to the older and less versatile MBR scheme."
msgstr "在这个例子中，将在新磁盘上创建一个单一的大分区。http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] 分区方案将被优先使用，而不是旧的、功能较少的 MBR 方案。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:91
msgid "If the disk to be added is not blank, old partition information can be removed with `gpart delete`.  See man:gpart[8] for details."
msgstr "如果要添加的磁盘不是空白的，可以用 `gpart delete` 来删除旧的分区信息。详见 man:gpart[8] 。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:95
msgid ""
"The partition scheme is created, and then a single partition is added.  To improve performance on newer disks with larger hardware block sizes, the partition is aligned "
"to one megabyte boundaries:"
msgstr "分区方案创建之后，添加一个单一的分区。为了提高在具有较大硬件块大小的新磁盘上的性能，分区边界被对齐到一兆字节："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:100
#, no-wrap
msgid ""
"# gpart create -s GPT ada1\n"
"# gpart add -t freebsd-ufs -a 1M ada1\n"
msgstr ""
"# gpart create -s GPT ada1\n"
"# gpart add -t freebsd-ufs -a 1M ada1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:104
msgid "Depending on use, several smaller partitions may be desired.  See man:gpart[8] for options to create partitions smaller than a whole disk."
msgstr "根据使用情况，可能需要几个更小的分区。参见 man:gpart[8] 以了解创建比整个磁盘小的分区的选项。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:106
msgid "The disk partition information can be viewed with `gpart show`:"
msgstr "磁盘分区信息可以用 `gpart show` 来查看："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:114
#, no-wrap
msgid ""
"% gpart show ada1\n"
"=>        34  1465146988  ada1  GPT  (699G)\n"
"          34        2014        - free -  (1.0M)\n"
"        2048  1465143296     1  freebsd-ufs  (699G)\n"
"  1465145344        1678        - free -  (839K)\n"
msgstr ""
"% gpart show ada1\n"
"=>        34  1465146988  ada1  GPT  (699G)\n"
"          34        2014        - free -  (1.0M)\n"
"        2048  1465143296     1  freebsd-ufs  (699G)\n"
"  1465145344        1678        - free -  (839K)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:117
msgid "A file system is created in the new partition on the new disk:"
msgstr "在新磁盘的新分区中创建一个文件系统："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:121
#, no-wrap
msgid "# newfs -U /dev/ada1p1\n"
msgstr "# newfs -U /dev/ada1p1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:124
msgid "An empty directory is created as a _mountpoint_, a location for mounting the new disk in the original disk's file system:"
msgstr "一个空目录被创建为 _挂载点_ ，这是一个用于在原磁盘的文件系统中挂载新磁盘分区的位置："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:128
#, no-wrap
msgid "# mkdir /newdisk\n"
msgstr "# mkdir /newdisk\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:131
msgid "Finally, an entry is added to [.filename]#/etc/fstab# so the new disk will be mounted automatically at startup:"
msgstr "最后，在 [.filename]#/etc/fstab# 中添加一个条目，这样新的磁盘分区将在启动时被自动挂载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:135
#, no-wrap
msgid "/dev/ada1p1\t/newdisk\tufs\trw\t2\t2\n"
msgstr "/dev/ada1p1\t/newdisk\tufs\trw\t2\t2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:138
msgid "The new disk can be mounted manually, without restarting the system:"
msgstr "可以手动挂载新的磁盘分区，不需要重新启动系统。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:142
#, no-wrap
msgid "# mount /newdisk\n"
msgstr "# mount /newdisk\n"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:145
#, no-wrap
msgid "Resizing and Growing Disks"
msgstr "调整和增加磁盘大小"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:151
msgid ""
"A disk's capacity can increase without any changes to the data already present.  This happens commonly with virtual machines, when the virtual disk turns out to be too "
"small and is enlarged.  Sometimes a disk image is written to a USB memory stick, but does not use the full capacity.  Here we describe how to resize or _grow_ disk "
"contents to take advantage of increased capacity."
msgstr ""
"可以增加一个磁盘的容量，而不需要对已经存在的数据做任何改变。这在虚拟机上经常使用，当虚拟机磁盘太小时可以增加容量。有时磁盘镜像被写入U盘，但没有使用全部容量。这里我们介绍"
"如何调整磁盘内容的大小，以利用增加的容量。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:154
msgid ""
"Determine the device name of the disk to be resized by inspecting [.filename]#/var/run/dmesg.boot#.  In this example, there is only one SATA disk in the system, so the "
"drive will appear as [.filename]#ada0#."
msgstr "通过检查 [.filename]#/var/run/dmesg.boot# 来确定要调整大小的磁盘的设备名称。在这个例子中，系统中只有一个 SATA 磁盘，所以该驱动器将显示为 [.filename]#ada0#。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:156
msgid "List the partitions on the disk to see the current configuration:"
msgstr "列出磁盘上的分区来查看当前的配置："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:165
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>      34  83886013  ada0  GPT  (48G) [CORRUPT]\n"
"        34       128     1  freebsd-boot  (64k)\n"
"       162  79691648     2  freebsd-ufs  (38G)\n"
"  79691810   4194236     3  freebsd-swap  (2G)\n"
"  83886046         1        - free -  (512B)\n"
msgstr ""
"# gpart show ada0\n"
"=>      34  83886013  ada0  GPT  (48G) [CORRUPT]\n"
"        34       128     1  freebsd-boot  (64k)\n"
"       162  79691648     2  freebsd-ufs  (38G)\n"
"  79691810   4194236     3  freebsd-swap  (2G)\n"
"  83886046         1        - free -  (512B)\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:171
msgid ""
"If the disk was formatted with the http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] partitioning scheme, it may show as \"corrupted\" because the GPT backup "
"partition table is no longer at the end of the drive.  Fix the backup partition table with `gpart`:"
msgstr ""
"如果磁盘是用 http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] 分区方案格式化的，它可能显示为 \"corrupted\" ，因为 GPT 备份分区表不再位于驱动器的末端。使用 `gpart` "
"修复备份分区表："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:176
#, no-wrap
msgid ""
"# gpart recover ada0\n"
"ada0 recovered\n"
msgstr ""
"# gpart recover ada0\n"
"ada0 recovered\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:181
msgid "Now the additional space on the disk is available for use by a new partition, or an existing partition can be expanded:"
msgstr "现在，磁盘上的额外空间可供一个新的分区使用，或者可以扩展一个现有的分区："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:190
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810    4194236     3  freebsd-swap  (2G)\n"
"   83886046   18513921        - free -  (8.8G)\n"
msgstr ""
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810    4194236     3  freebsd-swap  (2G)\n"
"   83886046   18513921        - free -  (8.8G)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:195
msgid ""
"Partitions can only be resized into contiguous free space.  Here, the last partition on the disk is the swap partition, but the second partition is the one that needs to "
"be resized.  Swap partitions only contain temporary data, so it can safely be unmounted, deleted, and then recreate the third partition after resizing the second "
"partition."
msgstr ""
"分区只能被调整到连续的自由空间。这里，磁盘上的最后一个分区是交换分区，但第二个分区是需要调整大小的分区。交换分区只包含临时数据，所以它可以安全地被卸载、删除，然后在调整第"
"二个分区的大小后重新创建第三个分区。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:197
msgid "Disable the swap partition:"
msgstr "禁用交换分区："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:201
#, no-wrap
msgid "# swapoff /dev/ada0p3\n"
msgstr "# swapoff /dev/ada0p3\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:204
msgid "Delete the third partition, specified by the `-i` flag, from the disk _ada0_."
msgstr "从磁盘 _ada0_ 中删除第三个分区，由 `-i` 标志指定："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:214
#, no-wrap
msgid ""
"# gpart delete -i 3 ada0\n"
"ada0p3 deleted\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810   22708157        - free -  (10G)\n"
msgstr ""
"# gpart delete -i 3 ada0\n"
"ada0p3 deleted\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810   22708157        - free -  (10G)\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:222
msgid ""
"There is risk of data loss when modifying the partition table of a mounted file system.  It is best to perform the following steps on an unmounted file system while "
"running from a live CD-ROM or USB device.  However, if absolutely necessary, a mounted file system can be resized after disabling GEOM safety features:"
msgstr ""
"在修改已挂载文件系统的分区表时，存在数据丢失的风险。最好是在一个未挂载的文件系统上执行以下步骤，并从 live CD-ROM 或 USB 设备上运行。然而，如果绝对必要，可以在禁用 GEOM 安"
"全功能后调整已挂载文件系统的大小。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:226
#, no-wrap
msgid "# sysctl kern.geom.debugflags=16\n"
msgstr "# sysctl kern.geom.debugflags=16\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:235
msgid ""
"Resize the partition, leaving room to recreate a swap partition of the desired size.  The partition to resize is specified with `-i`, and the new desired size with `-"
"s`.  Optionally, alignment of the partition is controlled with `-a`.  This only modifies the size of the partition.  The file system in the partition will be expanded in "
"a separate step."
msgstr ""
"调整分区的大小，留出空间来重新创建一个所需大小的交换分区。用 `-i` 指定要调整的分区，用 `-s` 指定新的期望大小。可以用 `-a` 来控制分区的对齐。这只是修改了分区的大小。分区中"
"的文件系统将在一个单独的步骤中被扩展。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:245
#, no-wrap
msgid ""
"# gpart resize -i 2 -s 47G -a 4k ada0\n"
"ada0p2 resized\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661        - free -  (1.8G)\n"
msgstr ""
"# gpart resize -i 2 -s 47G -a 4k ada0\n"
"ada0p2 resized\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661        - free -  (1.8G)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:249
msgid "Recreate the swap partition and activate it.  If no size is specified with `-s`, all remaining space is used:"
msgstr "重新创建交换分区并激活它。如果没有用 `-s` 指定大小，所有的剩余空间都会被使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:260
#, no-wrap
msgid ""
"# gpart add -t freebsd-swap -a 4k ada0\n"
"ada0p3 added\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661     3  freebsd-swap  (1.8G)\n"
"# swapon /dev/ada0p3\n"
msgstr ""
"# gpart add -t freebsd-swap -a 4k ada0\n"
"ada0p3 added\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661     3  freebsd-swap  (1.8G)\n"
"# swapon /dev/ada0p3\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:263
msgid "Grow the UFS file system to use the new capacity of the resized partition:"
msgstr "增大 UFS 文件系统，以使用调整后的分区的新容量："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:273
#, no-wrap
msgid ""
"# growfs /dev/ada0p2\n"
"Device is mounted read-write; resizing will result in temporary write suspension for /.\n"
"It's strongly recommended to make a backup before growing the file system.\n"
"OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes\n"
"super-block backups (for fsck -b #) at:\n"
" 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,\n"
" 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432\n"
msgstr ""
"# growfs /dev/ada0p2\n"
"Device is mounted read-write; resizing will result in temporary write suspension for /.\n"
"It's strongly recommended to make a backup before growing the file system.\n"
"OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes\n"
"super-block backups (for fsck -b #) at:\n"
" 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,\n"
" 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:276
msgid "If the file system is ZFS, the resize is triggered by running the `online` subcommand with `-e`:"
msgstr "如果文件系统是 ZFS，调整大小是通过运行带 `-e` 的 `online` 子命令来触发的："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:280
#, no-wrap
msgid "# zpool online -e zroot /dev/ada0p2\n"
msgstr "# zpool online -e zroot /dev/ada0p2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:283
msgid "Both the partition and the file system on it have now been resized to use the newly-available disk space."
msgstr "分区和其上的文件系统现在都已被调整大小，可以使用新的可用磁盘空间。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:285
#, no-wrap
msgid "USB Storage Devices"
msgstr "USB 存储设备"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:289
msgid ""
"Many external storage solutions, such as hard drives, USB thumbdrives, and CD and DVD burners, use the Universal Serial Bus (USB).  FreeBSD provides support for USB 1.x, "
"2.0, and 3.0 devices."
msgstr "许多外部存储解决方案，如硬盘、U 盘、CD 和 DVD 刻录机，都使用了通用串行总线(USB)。FreeBSD 提供对 USB 1.x、2.0 和 3.0 设备的支持。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:294
msgid ""
"USB 3.0 support is not compatible with some hardware, including Haswell (Lynx point) chipsets.  If FreeBSD boots with a `failed with error 19` message, disable xHCI/USB3 "
"in the system BIOS."
msgstr "USB 3.0 支持与某些硬件不兼容，包括 Haswell（Lynx point）芯片组。如果 FreeBSD 启动时出现 `failed with error 19` 的失败信息，请在系统 BIOS 中禁用 xHCI/USB3。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:298
msgid ""
"Support for USB storage devices is built into the [.filename]#GENERIC# kernel.  For a custom kernel, be sure that the following lines are present in the kernel "
"configuration file:"
msgstr "对USB存储设备的支持是内置于 [.filename]#GENERIC# 内核中的。对于一个自定义的内核，要确保在内核配置文件中存在以下几行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:311
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:315
msgid ""
"FreeBSD uses the man:umass[4] driver which uses the SCSI subsystem to access USB storage devices.  Since any USB device will be seen as a SCSI device by the system, if "
"the USB device is a CD or DVD burner, do _not_ include `device atapicam` in a custom kernel configuration file."
msgstr ""
"FreeBSD 使用 man:umass[4] 驱动程序，它使用 SCSI 子系统来访问 USB 存储设备。由于任何 USB 设备都会被系统视为 SCSI 设备，如果 USB 设备是 CD 或 DVD 刻录机，请不要在自定义的内"
"核配置文件中包含 `device atapicam` 。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:317
msgid "The rest of this section demonstrates how to verify that a USB storage device is recognized by FreeBSD and how to configure the device so that it can be used."
msgstr "本节的其余部分演示了如何验证 USB 存储设备是否被 FreeBSD 识别，以及如何配置设备以便使用。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:318
#, no-wrap
msgid "Device Configuration"
msgstr "设备配置"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:323
msgid ""
"To test the USB configuration, plug in the USB device.  Use `dmesg` to confirm that the drive appears in the system message buffer.  It should look something like this:"
msgstr "要测试 USB 配置，请插上 USB 设备。使用 `dmesg` 确认该驱动器出现在系统信息缓冲区中。它应该看起来像这样："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:335
#, no-wrap
msgid ""
"umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0\n"
"umass0:  SCSI over Bulk-Only; quirks = 0x0100\n"
"umass0:4:0:-1: Attached to scbus4\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device\n"
"da0: Serial Number WD-WXE508CAN263\n"
"da0: 40.000MB/s transfers\n"
"da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)\n"
"da0: quirks=0x2<NO_6_BYTE>\n"
msgstr ""
"umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0\n"
"umass0:  SCSI over Bulk-Only; quirks = 0x0100\n"
"umass0:4:0:-1: Attached to scbus4\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device\n"
"da0: Serial Number WD-WXE508CAN263\n"
"da0: 40.000MB/s transfers\n"
"da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)\n"
"da0: quirks=0x2<NO_6_BYTE>\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:338
msgid "The brand, device node ([.filename]#da0#), speed, and size will differ according to the device."
msgstr "品牌、设备节点（[.filename]#da0#）、速度和空间大小将因设备而异。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:340
msgid "Since the USB device is seen as a SCSI one, `camcontrol` can be used to list the USB storage devices attached to the system:"
msgstr "由于 USB 设备被看作是 SCSI 设备，`camcontrol` 可以用来列出连接到系统的 USB 存储设备："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:345
#, no-wrap
msgid ""
"# camcontrol devlist\n"
"<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)\n"
msgstr ""
"# camcontrol devlist\n"
"<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:349
msgid "Alternately, `usbconfig` can be used to list the device.  Refer to man:usbconfig[8] for more information about this command."
msgstr "另外，可以用 `usbconfig` 来列出设备。请参考 man:usbconfig[8] 以了解关于这个命令的更多信息。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:354
#, no-wrap
msgid ""
"# usbconfig\n"
"ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)\n"
msgstr ""
"# usbconfig\n"
"ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:358
msgid ""
"If the device has not been formatted, refer to <<disks-adding>> for instructions on how to format and create partitions on the USB drive.  If the drive comes with a file "
"system, it can be mounted by `root` using the instructions in crossref:basics[mount-unmount,“Mounting and Unmounting File Systems”]."
msgstr ""
"如果设备还没有被格式化，请参阅“添加磁盘”，了解如何在 U 盘上格式化和创建分区。如果驱动器带有文件系统，可以使用 crossref:basics[mount-unmount,挂载和卸载文件系统] 中的说明"
"在 `root` 用户下挂载。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:363
msgid ""
"Allowing untrusted users to mount arbitrary media, by enabling `vfs.usermount` as described below, should not be considered safe from a security point of view.  Most "
"file systems were not built to safeguard against malicious devices."
msgstr "通过启用下面描述的 `vfs.usermount`，允许不受信任的用户挂载任意的媒体是不安全的。大多数文件系统都不是为了防范恶意设备而建立的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:367
msgid ""
"To make the device mountable as a normal user, one solution is to make all users of the device a member of the `operator` group using man:pw[8].  Next, ensure that "
"`operator` is able to read and write the device by adding these lines to [.filename]#/etc/devfs.rules#:"
msgstr ""
"为了使普通用户可以挂载设备，可以使用 man:pw[8] 使设备的所有用户成为 `operator` 组的成员。接下来，通过在 [.filename]#/etc/devfs.rules# 中添加这些行，确保 `operator` 能够读"
"写设备："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:372
#, no-wrap
msgid ""
"[localrules=5]\n"
"add path 'da*' mode 0660 group operator\n"
msgstr ""
"[localrules=5]\n"
"add path 'da*' mode 0660 group operator\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:377
msgid "If internal SCSI disks are also installed in the system, change the second line as follows:"
msgstr "如果系统中也安装了内部 SCSI 磁盘，请将第二行修改如下："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:381
#, no-wrap
msgid "add path 'da[3-9]*' mode 0660 group operator\n"
msgstr "add path 'da[3-9]*' mode 0660 group operator\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:386
msgid ""
"This will exclude the first three SCSI disks ([.filename]#da0# to [.filename]#da2#) from belonging to the `operator` group.  Replace _3_ with the number of internal SCSI "
"disks.  Refer to man:devfs.rules[5] for more information about this file."
msgstr ""
"这将使前三个SCSI磁盘（ [.filename]#da0# 到 [.filename]#da2#）不属于 `operator` 组。用内部 SCSI 磁盘的数量代替 _3_ 。参考 man:devfs.rules[5] 了解更多关于这个文件的信息。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:389
msgid "Next, enable the ruleset in [.filename]#/etc/rc.conf#:"
msgstr "接下来，在 [.filename]#/etc/rc.conf# 中启用该规则集："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:393
#, no-wrap
msgid "devfs_system_ruleset=\"localrules\"\n"
msgstr "devfs_system_ruleset=\"localrules\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:396
msgid "Then, instruct the system to allow regular users to mount file systems by adding the following line to [.filename]#/etc/sysctl.conf#:"
msgstr "然后，在  [.filename]#/etc/sysctl.conf# 中添加以下一行，指示系统允许普通用户挂载文件系统："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:400
#, no-wrap
msgid "vfs.usermount=1\n"
msgstr "vfs.usermount=1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:403
msgid "Since this only takes effect after the next reboot, use `sysctl` to set this variable now:"
msgstr "因为这只在下次重启后生效，可以使用 `sysctl` 来立即设置这个变量："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:408
#, no-wrap
msgid ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"
msgstr ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:414
msgid ""
"The final step is to create a directory where the file system is to be mounted.  This directory needs to be owned by the user that is to mount the file system.  One way "
"to do that is for `root` to create a subdirectory owned by that user as [.filename]#/mnt/username#.  In the following example, replace _username_ with the login name of "
"the user and _usergroup_ with the user's primary group:"
msgstr ""
"最后一步是创建一个要挂载文件系统的目录。这个目录需要由要装载文件系统的用户拥有。一种方法是让 `root` 创建一个由该用户拥有的 [.filename]#/mnt/username# 子目录。在下面的例子"
"中，用用户的登录名代替 _username_，用用户的主组代替 _usergroup_："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:419
#, no-wrap
msgid ""
"# mkdir /mnt/username\n"
"# chown username:usergroup /mnt/username\n"
msgstr ""
"# mkdir /mnt/username\n"
"# chown username:usergroup /mnt/username\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:423
msgid ""
"Suppose a USB thumbdrive is plugged in, and a device [.filename]#/dev/da0s1# appears.  If the device is formatted with a FAT file system, the user can mount it using:"
msgstr "假设一个 U 盘被插入，并且出现了一个设备 [.filename]#/dev/da0s1# 。如果该设备是用 FAT 文件系统格式化的，用户可以用以下方法挂载它："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:427
#, no-wrap
msgid "% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username\n"
msgstr "% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:430
msgid "Before the device can be unplugged, it _must_ be unmounted first:"
msgstr "在拔掉设备的插头之前，必须先将其卸载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:434
#, no-wrap
msgid "% umount /mnt/username\n"
msgstr "% umount /mnt/username\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:437
msgid "After device removal, the system message buffer will show messages similar to the following:"
msgstr "移除设备后，系统信息缓冲区将显示类似以下的信息："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:444
#, no-wrap
msgid ""
"umass0: at uhub3, port 2, addr 3 (disconnected)\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached\n"
"(da0:umass-sim0:0:0:0): Periph destroyed\n"
msgstr ""
"umass0: at uhub3, port 2, addr 3 (disconnected)\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached\n"
"(da0:umass-sim0:0:0:0): Periph destroyed\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:446
#, no-wrap
msgid "Automounting Removable Media"
msgstr "自动挂载可移动媒体"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:449
msgid "USB devices can be automatically mounted by uncommenting this line in [.filename]#/etc/auto_master#:"
msgstr "通过取消对 [.filename]#/etc/auto_master# 中这一行的注释，USB 设备可以被自动挂载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:453
#, no-wrap
msgid "/media\t\t-media\t\t-nosuid\n"
msgstr "/media\t\t-media\t\t-nosuid\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:456
msgid "Then add these lines to [.filename]#/etc/devd.conf#:"
msgstr "然后在 [.filename]#/etc/devd.conf# 中添加这些行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:464
#, no-wrap
msgid ""
"notify 100 {\n"
"\tmatch \"system\" \"GEOM\";\n"
"\tmatch \"subsystem\" \"DEV\";\n"
"\taction \"/usr/sbin/automount -c\";\n"
"};\n"
msgstr ""
"notify 100 {\n"
"\tmatch \"system\" \"GEOM\";\n"
"\tmatch \"subsystem\" \"DEV\";\n"
"\taction \"/usr/sbin/automount -c\";\n"
"};\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:467
msgid "Reload the configuration if man:autofs[5] and man:devd[8] are already running:"
msgstr "如果 man:autofs[5] 和 man:devd[8] 已经在运行，可以重新加载配置："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:472
#, no-wrap
msgid ""
"# service automount restart\n"
"# service devd restart\n"
msgstr ""
"# service automount restart\n"
"# service devd restart\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:475
msgid "man:autofs[5] can be set to start at boot by adding this line to [.filename]#/etc/rc.conf#:"
msgstr "可以通过在 [.filename]#/etc/rc.conf# 中添加这行来设置为在启动时启动 man:autofs[5]："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:479
#, no-wrap
msgid "autofs_enable=\"YES\"\n"
msgstr "autofs_enable=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:482
msgid "man:autofs[5] requires man:devd[8] to be enabled, as it is by default."
msgstr "man:autofs[5] 需要启用 man:devd[8] ，它在默认情况下是启用的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:484
msgid "Start the services immediately with:"
msgstr "使用如下命令立即启动服务："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:491
#, no-wrap
msgid ""
"# service automount start\n"
"# service automountd start\n"
"# service autounmountd start\n"
"# service devd start\n"
msgstr ""
"# service automount start\n"
"# service automountd start\n"
"# service autounmountd start\n"
"# service devd start\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:496
msgid ""
"Each file system that can be automatically mounted appears as a directory in [.filename]#/media/#.  The directory is named after the file system label.  If the label is "
"missing, the directory is named after the device node."
msgstr "每个可以自动挂载的文件系统在 [.filename]#/media/# 中显示为一个目录。该目录是以文件系统的标签命名的。如果标签缺失，该目录就以设备节点命名"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:499
msgid "The file system is transparently mounted on the first access, and unmounted after a period of inactivity.  Automounted drives can also be unmounted manually:"
msgstr "文件系统在第一次访问时被透明地挂载，并在一段时间的非活动后被取消挂载。也可以手动卸载自动挂载的驱动器："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:503
#, no-wrap
msgid "# automount -fu\n"
msgstr "# automount -fu\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:507
msgid "This mechanism is typically used for memory cards and USB memory sticks.  It can be used with any block device, including optical drives or iSCSILUNs."
msgstr "这种机制通常用于存储卡和 U 盘。它可以用于任何块状设备，包括光驱或 iSCSILUN。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:509
#, no-wrap
msgid "Creating and Using CD Media"
msgstr "创建和使用 CD 媒体"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:515
msgid ""
"Compact Disc (CD) media provide a number of features that differentiate them from conventional disks.  They are designed so that they can be read continuously without "
"delays to move the head between tracks.  While CD media do have tracks, these refer to a section of data to be read continuously, and not a physical property of the "
"disk.  The ISO 9660 file system was designed to deal with these differences."
msgstr ""
"紧凑型光盘（CD）媒体提供了一些区别于传统磁盘的特点。它们被设计成可以连续读取，而不需要延迟在轨道之间移动磁头。虽然 CD 介质确实有轨道，但这是指要连续读取的数据部分，而不是"
"磁盘的物理属性。ISO 9660 文件系统就是为了处理这些差异而设计的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:519
msgid ""
"The FreeBSD Ports Collection provides several utilities for burning and duplicating audio and data CDs.  This chapter demonstrates the use of several command line "
"utilities.  For CD burning software with a graphical utility, consider installing the package:sysutils/xcdroast[] or package:sysutils/k3b[] packages or ports."
msgstr ""
"FreeBSD Ports Collection 提供了几个用于刻录和复制音频和数据光盘的实用程序。这一章演示了几个命令行实用程序的使用。对于带有图形化工具的 CD 刻录软件，"
"可以考虑安装 package:sysutils/xcdroast[] 或 package:sysutils/k3b[] 包或 port。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:521
#, no-wrap
msgid "Supported Devices"
msgstr "支持的设备"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:525
msgid ""
"The [.filename]#GENERIC# kernel provides support for SCSI, USB, and ATAPICD readers and burners.  If a custom kernel is used, the options that need to be present in the "
"kernel configuration file vary by the type of device."
msgstr "[.filename]#GENERIC# 内核提供了对 SCSI ，USB 和 ATAPICD 读卡器和刻录机的支持。如果使用自定义内核，需要在内核配置文件中出现的选项因设备的类型而异。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:527
msgid "For a SCSI burner, make sure these options are present:"
msgstr "对于 SCSI 刻录机，确保这些选项是存在的："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:534
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:537
msgid "For a USB burner, make sure these options are present:"
msgstr "对于USB刻录机，确保这些选项是存在的："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:550
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:553
msgid "For an ATAPI burner, make sure these options are present:"
msgstr "对于 ATAPI 刻录机，要确保这些选项是存在的"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:560
#, no-wrap
msgid ""
"device ata\t# Legacy ATA/SATA controllers\n"
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device ata\t# Legacy ATA/SATA controllers\n"
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:565
msgid "On FreeBSD versions prior to 10.x, this line is also needed in the kernel configuration file if the burner is an ATAPI device:"
msgstr "在 10.x 之前的 FreeBSD 版本中，如果刻录机是 ATAPI 设备，在内核配置文件中也需要这一行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:569
#, no-wrap
msgid "device atapicam\n"
msgstr "device atapicam\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:572
msgid "Alternately, this driver can be loaded at boot time by adding the following line to [.filename]#/boot/loader.conf#:"
msgstr "另外，通过在 [.filename]#/boot/loader.conf# 中添加以下一行，可以在启动时加载该驱动："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:576
#, no-wrap
msgid "atapicam_load=\"YES\"\n"
msgstr "atapicam_load=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:579
msgid "This will require a reboot of the system as this driver can only be loaded at boot time."
msgstr "这将需要重新启动系统，因为这个驱动程序只能在启动时加载。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:583
msgid ""
"To verify that FreeBSD recognizes the device, run `dmesg` and look for an entry for the device.  On systems prior to 10.x, the device name in the first line of the "
"output will be [.filename]#acd0# instead of [.filename]#cd0#."
msgstr "为了验证 FreeBSD 是否识别该设备，运行 `dmesg` 并寻找该设备的条目。在10.x之前的系统中，输出的第一行中的设备名称将是 [.filename]#acd0# 而不是 [.filename]#cd0#："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:592
#, no-wrap
msgid ""
"% dmesg | grep cd\n"
"cd0 at ahcich1 bus 0 scbus1 target 0 lun 0\n"
"cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device\n"
"cd0: Serial Number M3OD3S34152\n"
"cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)\n"
"cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed\n"
msgstr ""
"% dmesg | grep cd\n"
"cd0 at ahcich1 bus 0 scbus1 target 0 lun 0\n"
"cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device\n"
"cd0: Serial Number M3OD3S34152\n"
"cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)\n"
"cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:595
#, no-wrap
msgid "Burning a CD"
msgstr "刻录光盘"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:599
msgid "In FreeBSD, `cdrecord` can be used to burn CDs.  This command is installed with the package:sysutils/cdrtools[] package or port."
msgstr "在 FreeBSD 中，`cdrecord` 可以用来刻录 CD。这个命令被安装在 package:sysutils/cdrtools[] 软件包或 port 中"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:602
msgid ""
"While `cdrecord` has many options, basic usage is simple.  Specify the name of the ISO file to burn and, if the system has multiple burner devices, specify the name of "
"the device to use:"
msgstr "虽然 `cdrecord` 有许多选项，但基本用法很简单。指定要刻录的 ISO 文件的名称，如果系统有多个刻录机设备，则指定要使用的设备的名称："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:606
#, no-wrap
msgid "# cdrecord dev=device imagefile.iso\n"
msgstr "# cdrecord dev=device imagefile.iso\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:609
msgid "To determine the device name of the burner, use `-scanbus` which might produce results like this:"
msgstr "为了确定刻录机的设备名称，使用 `-scanbus` ，可能产生这样的结果："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:633
#, no-wrap
msgid ""
"# cdrecord -scanbus\n"
"ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling\n"
"Using libscg version 'schily-0.9'\n"
"scsibus0:\n"
"        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk\n"
"        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk\n"
"        0,2,0     2) *\n"
"        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk\n"
"        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM\n"
"        0,5,0     5) *\n"
"        0,6,0     6) *\n"
"        0,7,0     7) *\n"
"scsibus1:\n"
"        1,0,0   100) *\n"
"        1,1,0   101) *\n"
"        1,2,0   102) *\n"
"        1,3,0   103) *\n"
"        1,4,0   104) *\n"
"        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM\n"
"        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner\n"
"        1,7,0   107) *\n"
msgstr ""
"# cdrecord -scanbus\n"
"ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling\n"
"Using libscg version 'schily-0.9'\n"
"scsibus0:\n"
"        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk\n"
"        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk\n"
"        0,2,0     2) *\n"
"        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk\n"
"        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM\n"
"        0,5,0     5) *\n"
"        0,6,0     6) *\n"
"        0,7,0     7) *\n"
"scsibus1:\n"
"        1,0,0   100) *\n"
"        1,1,0   101) *\n"
"        1,2,0   102) *\n"
"        1,3,0   103) *\n"
"        1,4,0   104) *\n"
"        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM\n"
"        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner\n"
"        1,7,0   107) *\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:638
msgid ""
"Locate the entry for the CD burner and use the three numbers separated by commas as the value for `dev`.  In this case, the Yamaha burner device is `1,5,0`, so the "
"appropriate input to specify that device is `dev=1,5,0`.  Refer to the manual page for `cdrecord` for other ways to specify this value and for information on writing "
"audio tracks and controlling the write speed."
msgstr ""
"找到 CD 刻录机的条目，用逗号分隔的三个数字作为 `dev` 的值。在本例中，Yamaha 刻录机的设备是 `1,5,0`，所以指定该设备的适当输入是 `dev=1,5,0` 。参考 `cdrecord` 的手册页，了"
"解指定该值的其他方法，以及关于写入音轨和控制写入速度的信息。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:640
msgid "Alternately, run the following command to get the device address of the burner:"
msgstr "另外，还运行下面的命令来获得刻录机的设备地址："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:645
#, no-wrap
msgid ""
"# camcontrol devlist\n"
"<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)\n"
msgstr ""
"# camcontrol devlist\n"
"<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:649
msgid "Use the numeric values for `scbus`, `target`, and `lun`.  For this example, `1,0,0` is the device name to use."
msgstr "使用 `scbus`、 `target` 和 `lun` 的数字值。在这个例子中，`1,0,0` 是要使用的设备名称。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:651
#, no-wrap
msgid "Writing Data to an ISO File System"
msgstr "将数据写入 ISO 文件系统"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:656
msgid ""
"In order to produce a data CD, the data files that are going to make up the tracks on the CD must be prepared before they can be burned to the CD.  In FreeBSD, package:"
"sysutils/cdrtools[] installs `mkisofs`, which can be used to produce an ISO 9660 file system that is an image of a directory tree within a UNIX(R) file system.  The "
"simplest usage is to specify the name of the ISO file to create and the path to the files to place into the ISO 9660 file system:"
msgstr ""
"为了制作数据光盘，在刻录到光盘上之前必须准备好构成光盘轨道的数据文件。在 FreeBSD 中，package:sysutils/cdrtools[] 安装了 `mkisofs` ，它可以用来制作一个 ISO 9660 文件系统，"
"它是 UNIX(R) 文件系统中目录树的一个映像。最简单的用法是指定要创建的 ISO 文件的名称和要放入 ISO 9660 文件系统的文件的路径："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:660
#, no-wrap
msgid "# mkisofs -o imagefile.iso /path/to/tree\n"
msgstr "# mkisofs -o imagefile.iso /path/to/tree\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:663
msgid ""
"This command maps the file names in the specified path to names that fit the limitations of the standard ISO 9660 file system, and will exclude files that do not meet "
"the standard for ISO file systems."
msgstr "该命令将指定路径中的文件名映射为符合标准 ISO 9660 文件系统限制的名称，并将排除不符合 ISO 有一些选项可以用来克服标准所施加的限制。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:666
msgid ""
"A number of options are available to overcome the restrictions imposed by the standard.  In particular, `-R` enables the Rock Ridge extensions common to UNIX(R) systems "
"and `-J` enables Joliet extensions used by Microsoft(R) systems."
msgstr "有许多选项可以克服该标准所施加的限制。特别是，`-R` 启用 UNIX(R) 系统常用的 Rock Ridge 扩展，`-J` 启用 Microsoft(R) 系统使用的 Joliet 扩展。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:669
msgid ""
"For CDs that are going to be used only on FreeBSD systems, `-U` can be used to disable all filename restrictions.  When used with `-R`, it produces a file system image "
"that is identical to the specified FreeBSD tree, even if it violates the ISO 9660 standard."
msgstr ""
"对于只在 FreeBSD 系统上使用的光盘，可以用 `-U` 来禁用所有的文件名限制。当与 `-R` 一起使用时，它产生的文件系统映像与指定的 FreeBSD tree 相同，即使它违反了 ISO 9660 标准。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:677
msgid ""
"The last option of general use is `-b`.  This is used to specify the location of a boot image for use in producing an \"El Torito\" bootable CD.  This option takes an "
"argument which is the path to a boot image from the top of the tree being written to the CD.  By default, `mkisofs` creates an ISO image in \"floppy disk emulation\" "
"mode, and thus expects the boot image to be exactly 1200, 1440 or 2880 KB in size.  Some boot loaders, like the one used by the FreeBSD distribution media, do not use "
"emulation mode.  In this case, `-no-emul-boot` should be used.  So, if [.filename]#/tmp/myboot# holds a bootable FreeBSD system with the boot image in [.filename]#/tmp/"
"myboot/boot/cdboot#, this command would produce [.filename]#/tmp/bootable.iso#:"
msgstr ""
"最后一个一般使用的选项是 `-b`。它被用来指定用于生产 \"El Torito\" 可引导光盘的引导镜像的位置。这个选项需要一个参数，它是被写入光盘的树顶的引导映像的路径。默认情况下，"
"`mkisofs` 在“软盘仿真”模式下创建 ISO 映像，因此希望引导映像的大小正好是 1200、1440 或 2880 KB。一些 BootLoader，像 FreeBSD 发行媒体使用的那种，不使用仿真模式。在这种情况"
"下，应该使用 `-no-emul-boot`。因此，如果 [.filename]#/tmp/myboot# 持有一个可启动的 FreeBSD 系统，其启动镜像在 [.filename]#/tmp/myboot/boot/cdboot# 中，"
"这个命令将产生 [.filename]#/tmp/bootable.iso#："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:681
#, no-wrap
msgid "# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot\n"
msgstr "# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:684
msgid "The resulting ISO image can be mounted as a memory disk with:"
msgstr "由此产生的 ISO 镜像可以作为内存盘挂载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:689
#, no-wrap
msgid ""
"# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"
msgstr ""
"# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:692
msgid "One can then verify that [.filename]#/mnt# and [.filename]#/tmp/myboot# are identical."
msgstr "然后我们可以验证 [.filename]#/mnt# 和 [.filename]#/tmp/myboot# 是相同的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:695
msgid "There are many other options available for `mkisofs` to fine-tune its behavior.  Refer to man:mkisofs[8] for details."
msgstr "`mkisofs` 还有许多其他选项可以用来微调其行为。详情请参考 man:mkisofs[8]。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:700
msgid ""
"It is possible to copy a data CD to an image file that is functionally equivalent to the image file created with `mkisofs`.  To do so, use [.filename]#dd# with the "
"device name as the input file and the name of the ISO to create as the output file:"
msgstr ""
"可以将数据光盘复制到一个镜像文件中，该文件在功能上与用 `mkisofs` 创建的镜像文件相当。要做到这一点，使用 [.filename]#dd#,将设备名称作为输入文件，将要创建的 ISO 的名称作为"
"输出文件："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:704
#, no-wrap
msgid "# dd if=/dev/cd0 of=file.iso bs=2048\n"
msgstr "# dd if=/dev/cd0 of=file.iso bs=2048\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:707
msgid "The resulting image file can be burned to CD as described in <<cdrecord>>."
msgstr "产生的映像文件可以按照刻录光盘中的描述刻录到光盘上。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:710
#, no-wrap
msgid "Using Data CDs"
msgstr "使用数据光盘"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:713
msgid "Once an ISO has been burned to a CD, it can be mounted by specifying the file system type, the name of the device containing the CD, and an existing mount point:"
msgstr "ISO 被刻录到光盘上以后，就可以通过指定文件系统类型、包含光盘的设备名称和一个现有的挂载点来挂载它："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:717
#, no-wrap
msgid "# mount -t cd9660 /dev/cd0 /mnt\n"
msgstr "# mount -t cd9660 /dev/cd0 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:720
msgid "Since `mount` assumes that a file system is of type `ufs`, an `Incorrect super block` error will occur if `-t cd9660` is not included when mounting a data CD."
msgstr "由于挂载时假定文件系统是 `ufs` 类型的，如果在挂载数据光盘时不包括 `-t cd9660` ，将产生 `Incorrect super block` 错误。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:725
msgid ""
"While any data CD can be mounted this way, disks with certain ISO 9660 extensions might behave oddly.  For example, Joliet disks store all filenames in two-byte Unicode "
"characters.  If some non-English characters show up as question marks, specify the local charset with `-C`.  For more information, refer to man:mount_cd9660[8]."
msgstr ""
"虽然任何数据光盘都可以这样挂载，但具有某些 ISO 9660 扩展名的磁盘可能表现得很奇怪。例如，Joliet 磁盘以两字节的 Unicode 字符存储所有文件名。如果一些非英语字符显示为问号，请"
"用 `-C` 指定本地字符集。更多信息，请参考 man:mount_cd9660[8]。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:730
msgid ""
"In order to do this character conversion with the help of `-C`, the kernel requires the [.filename]#cd9660_iconv.ko# module to be loaded.  This can be done either by "
"adding this line to [.filename]#loader.conf#:"
msgstr "为了使用 `-C` 进行这种字符转换，内核需要加载 [.filename]#cd9660_iconv.ko# 模块。这可以通过在 [.filename]#loader.conf# 中加入这一行来完成："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:734
#, no-wrap
msgid "cd9660_iconv_load=\"YES\"\n"
msgstr "cd9660_iconv_load=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:737
msgid "and then rebooting the machine, or by directly loading the module with `kldload`."
msgstr "然后重启机器，或者直接用 `kldload` 加载模块。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:742
msgid ""
"Occasionally, `Device not configured` will be displayed when trying to mount a data CD.  This usually means that the CD drive has not detected a disk in the tray, or "
"that the drive is not visible on the bus.  It can take a couple of seconds for a CD drive to detect media, so be patient."
msgstr ""
"偶尔，当试图装载数据光盘时，会显示 `Device not configured`。这通常意味着光盘驱动器没有检测到托盘中的磁盘，或者驱动器在总线上不可见。光驱检测介质可能需要几秒钟的时间，所以"
"要有耐心。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:746
msgid ""
"Sometimes, a SCSICD drive may be missed because it did not have enough time to answer the bus reset.  To resolve this, a custom kernel can be created which increases the "
"default SCSI delay.  Add the following option to the custom kernel configuration file and rebuild the kernel using the instructions in crossref:kernelconfig[kernelconfig-"
"building,“Building and Installing a Custom Kernel”]:"
msgstr ""
"有时，SCSI CD 驱动器可能会被遗漏，因为它没有足够的时间来回答总线复位。为了解决这个问题，可以创建一个自定义内核，增加默认的 SCSI 延迟。在定制的内核配置文件中增加以下选项，"
"并按照 crossref:kernelconfig[kernelconfig-building,构建和安装定制的内核] 的说明重建内核："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:750
#, no-wrap
msgid "options SCSI_DELAY=15000\n"
msgstr "options SCSI_DELAY=15000\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:753
msgid "This tells the SCSI bus to pause 15 seconds during boot, to give the CD drive every possible chance to answer the bus reset."
msgstr "这让 SCSI 总线在启动过程中暂停 15 秒，以便给 CD 驱动器一切可能的机会来回答总线的复位。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:758
msgid ""
"It is possible to burn a file directly to CD, without creating an ISO 9660 file system.  This is known as burning a raw data CD and some people do this for backup "
"purposes."
msgstr "可以直接将文件刻录到光盘上，而不创建 ISO 9660 文件系统。这就是所谓的刻录原始数据光盘，有些人为了备份会这样做。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:762
msgid ""
"This type of disk can not be mounted as a normal data CD.  In order to retrieve the data burned to such a CD, the data must be read from the raw device node.  For "
"example, this command will extract a compressed tar file located on the second CD device into the current working directory:"
msgstr ""
"这种类型的磁盘不能像普通的数据光盘一样被挂载。为了检索刻录到这种光盘上的数据，必须从原始设备节点上读取数据。例如，这个命令将把位于第二个 CD 设备上的压缩 tar 文件提取到当"
"前工作目录中："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:766
#, no-wrap
msgid "# tar xzvf /dev/cd1\n"
msgstr "# tar xzvf /dev/cd1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:769
msgid "In order to mount a data CD, the data must be written using `mkisofs`."
msgstr "为了挂载数据光盘，必须使用 `mkisofs` 写入数据。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:772
#, no-wrap
msgid "Duplicating Audio CDs"
msgstr "复制音频CD"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:775
msgid "To duplicate an audio CD, extract the audio data from the CD to a series of files, then write these files to a blank CD."
msgstr "要复制一张音频 CD ，把 CD 上的音频数据提取成一系列的文件，然后把这些文件写入一张空白 CD 。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:778
msgid ""
"<<using-cdrecord>> describes how to duplicate and burn an audio CD.  If the FreeBSD version is less than 10.0 and the device is ATAPI, the `atapicam` module must be "
"first loaded using the instructions in <<atapicam>>."
msgstr "本节描述了如何复制和刻录一张音频 CD。如果 FreeBSD 的版本小于 10.0，并且设备是 ATAPI 总线，必须首先加载 atapicam 模块。"

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:781
#, no-wrap
msgid "Procedure: Duplicating an Audio CD"
msgstr "程序：复制一张音频CD"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:783
msgid ""
"The package:sysutils/cdrtools[] package or port installs `cdda2wav`. This command can be used to extract all of the audio tracks, with each track written to a separate "
"WAV file in the current working directory:"
msgstr "package:sysutils/cdrtools[] 软件包或 port 安装了 `cdda2wav` 。这个命令可以用来提取所有的音轨，每个音轨都写在当前工作目录下的一个单独的 WAV 文件中："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:787
#, no-wrap
msgid "% cdda2wav -vall -B -Owav\n"
msgstr "% cdda2wav -vall -B -Owav\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:791
msgid ""
"A device name does not need to be specified if there is only one CD device on the system.  Refer to the `cdda2wav` manual page for instructions on how to specify a "
"device and to learn more about the other options available for this command."
msgstr "如果系统上只有一个 CD 设备，则不需要指定设备名。参考 `cdda2wav` 手册中关于如何指定一个设备的说明，并了解更多关于这个命令的其他选项。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:792
msgid "Use `cdrecord` to write the [.filename]#.wav# files:"
msgstr "用 `cdrecord` 来写入 [.filename]#.wav# 文件。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:796
#, no-wrap
msgid "% cdrecord -v dev=2,0 -dao -useinfo  *.wav\n"
msgstr "% cdrecord -v dev=2,0 -dao -useinfo  *.wav\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:799
msgid "Make sure that _2,0_ is set appropriately, as described in <<cdrecord>>."
msgstr "确保设置了 _2,0_。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:801
#, no-wrap
msgid "Creating and Using DVD Media"
msgstr "创建和使用 DVD 媒体"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:805
msgid ""
"Compared to the CD, the DVD is the next generation of optical media storage technology.  The DVD can hold more data than any CD and is the standard for video publishing."
msgstr "与 CD 相比，DVD 是下一代的光学媒体存储技术。DVD 可以比任何 CD 容纳更多的数据，是视频出版的标准。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:807
msgid "Five physical recordable formats can be defined for a recordable DVD:"
msgstr "可刻录 DVD 有五种物理格式："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:809
msgid ""
"DVD-R: This was the first DVD recordable format available. The DVD-R standard is defined by the http://www.dvdforum.org/forum.shtml[DVD Forum]. This format is write once."
msgstr "DVD-R：这是第一个可用的 DVD 可记录格式。DVD-R 标准是由 http://www.dvdforum.org/forum.shtml[DVD Forum] 定义的。这种格式是一次写入。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:810
msgid "DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can be rewritten about 1000 times."
msgstr "DVD-RW: 这是 DVD-R 标准的可重写版本。一张 DVD-RW 可以被重写 1000 次左右。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:811
msgid ""
"DVD-RAM: This is a rewritable format which can be seen as a removable hard drive. However, this media is not compatible with most DVD-ROM drives and DVD-Video players as "
"only a few DVD writers support the DVD-RAM format. Refer to <<creating-dvd-ram>> for more information on DVD-RAM use."
msgstr ""
"DVD-RAM: 这是一种可重写的格式，可以被看作是一种可移动的硬盘驱动器。然而，这种媒体与大多数 DVD-ROM 驱动器和 DVD 视频播放器不兼容，只有少数 DVD 写入器支持 DVD-RAM 格式。请"
"参考使用 DVD-RAM，了解更多关于 DVD-RAM 的使用信息。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:812
msgid "DVD+RW: This is a rewritable format defined by the https://en.wikipedia.org/wiki/DVD%2BRW_Alliance[DVD+RW Alliance]. A DVD+RW can be rewritten about 1000 times."
msgstr "DVD+RW: 这是一种由 https://en.wikipedia.org/wiki/DVD%2BRW_Alliance[DVD+RW Alliance] 定义的可重写格式。一张 DVD+RW 可以被重写大约 1000 次。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:813
msgid "DVD+R: This format is the write once variation of the DVD+RW format."
msgstr "DVD+R: 这种格式是 DVD+RW 格式的一次写入变体。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:815
msgid "A single layer recordable DVD can hold up to 4,700,000,000 bytes which is actually 4.38 GB or 4485 MB as 1 kilobyte is 1024 bytes."
msgstr "一张单层可刻录的 DVD 可以容纳 4,700,000,000 字节，实际上是 4.38GB 或 4485MB，因为 1 千字节是 1024 字节。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:821
msgid ""
"A distinction must be made between the physical media and the application.  For example, a DVD-Video is a specific file layout that can be written on any recordable DVD "
"physical media such as DVD-R, DVD+R, or DVD-RW.  Before choosing the type of media, ensure that both the burner and the DVD-Video player are compatible with the media "
"under consideration."
msgstr ""
"必须对物理介质和应用程序进行区分。例如，DVD-Video 是一种特定的文件布局，可以写在任何 DVD 物理介质上，如 DVD-R、DVD+R 或 DVD-RW。在选择媒体类型之前，要确保刻录机和 DVD 视"
"频播放器都能与要选择的媒体兼容。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:823
#, no-wrap
msgid "Configuration"
msgstr "配置"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:827
msgid "To perform DVD recording, use man:growisofs[1].  This command is part of the package:sysutils/dvd+rw-tools[] utilities which support all DVD media types."
msgstr "要执行 DVD 刻录，请使用 man:growisofs[1]。这个命令是 package:sysutils/dvd+rw-tools[] 工具的一部分，它支持所有 DVD 媒体类型。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:831
msgid ""
"These tools use the SCSI subsystem to access the devices, therefore <<atapicam,ATAPI/CAM support>> must be loaded or statically compiled into the kernel.  This support "
"is not needed if the burner uses the USB interface.  Refer to <<usb-disks>> for more details on USB device configuration."
msgstr ""
"这些工具使用 SCSI 子系统来访问设备，因此 ATAPI/CAM 必须被加载或静态编译到内核中。如果刻录机使用 USB 接口，则不需要这种支持。关于 USB 设备配置的更多细节，请参考 [USB 存储"
"设备]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:833
msgid "DMA access must also be enabled for ATAPI devices, by adding the following line to [.filename]#/boot/loader.conf#:"
msgstr "还必须为 ATAPI 设备启用 DMA 访问，在 [.filename]#/boot/loader.conf# 中添加以下一行。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:837 content/zh-cn/books/handbook/disks/_index.adoc:1070
#, no-wrap
msgid "hw.ata.atapi_dma=\"1\"\n"
msgstr "hw.ata.atapi_dma=\"1\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:840
msgid "Before attempting to use dvd+rw-tools, consult the http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[Hardware Compatibility Notes]."
msgstr "在尝试使用dvd+rw-tools之前，请查阅 http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[硬件兼容性说明]。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:844
msgid "For a graphical user interface, consider using package:sysutils/k3b[] which provides a user friendly interface to man:growisofs[1] and many other burning tools."
msgstr "对于图形用户界面，可以考虑使用 package:sysutils/k3b[] ，它为 man:growisofs[1] 和许多其他刻录工具提供了一个用户友好的界面。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:846
#, no-wrap
msgid "Burning Data DVDs"
msgstr "刻录数据 DVD"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:850
msgid ""
"Since man:growisofs[1] is a front-end to <<mkisofs,mkisofs>>, it will invoke man:mkisofs[8] to create the file system layout and perform the write on the DVD.  This "
"means that an image of the data does not need to be created before the burning process."
msgstr "由于 man:growisofs[1] 是 mkisofs 的前端，它将调用 man:mkisofs[8] 来创建文件系统布局并在 DVD 上执行写入。这意味着在刻录过程中不需要创建数据的镜像。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:852
msgid "To burn to a DVD+R or a DVD-R the data in [.filename]#/path/to/data#, use the following command:"
msgstr "要将 [.filename]#/path/to/data# 中的数据刻录到 DVD+R 或 DVD-R 上，请使用以下命令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:856
#, no-wrap
msgid "# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:860
msgid ""
"In this example, `-J -R` is passed to man:mkisofs[8] to create an ISO 9660 file system with Joliet and Rock Ridge extensions.  Refer to man:mkisofs[8] for more details."
msgstr "在这个例子中，`-J -R` 被传递给 man:mkisofs[8] 来创建一个带有 Joliet 和 Rock Ridge 扩展的 ISO 9660 文件系统。更多细节请参考 man:mkisofs[8]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:865
msgid ""
"For the initial session recording, `-Z` is used for both single and multiple sessions.  Replace _/dev/cd0_, with the name of the DVD device.  Using `-dvd-compat` "
"indicates that the disk will be closed and that the recording will be unappendable.  This should also provide better media compatibility with DVD-ROM drives."
msgstr ""
"对于初次刻录，`-Z` 用于单次和多次会话。用DVD设备的名称替换 _/dev/cd0_。使用 `-dvd-compat` 表示磁盘将被关闭，录制的内容将无法追加。这也应该提供与 DVD-ROM 驱动器更好的媒体"
"兼容性。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:867
msgid "To burn a pre-mastered image, such as _imagefile.iso_, use:"
msgstr "要刻录一个预制的图像，如 _imagefile.iso_，使用:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:871
#, no-wrap
msgid "# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso\n"
msgstr "# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:875
msgid ""
"The write speed should be detected and automatically set according to the media and the drive being used.  To force the write speed, use `-speed=`. Refer to man:"
"growisofs[1] for example usage."
msgstr "写入速度根据介质和正在使用的驱动器自动设置。要强制设置写入速度，请使用 `-speed=` 。请参考 man:growisofs[1] 的例子用法。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:882
msgid ""
"In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid file system must be created by passing `-udf -iso-level 3` to man:mkisofs[8] and all related "
"programs, such as man:growisofs[1].  This is required only when creating an ISO image file or when writing files directly to a disk.  Since a disk created this way must "
"be mounted as an UDF file system with man:mount_udf[8], it will be usable only on an UDF aware operating system.  Otherwise it will look as if it contains corrupted "
"files."
msgstr ""
"为了支持大于 4.38GB 的工作文件，必须通过向 man:mkisofs[8] 和所有相关程序，如 man:growisofs[1] 传递 `-udf -iso-level 3` 来创建一个 UDF/ISO-9660 混合文件系统。只有在创建 "
"ISO 镜像文件或直接向磁盘写入文件时才需要这样做。由于以这种方式创建的磁盘必须用 man:mount_udf[8] 挂载为 UDF 文件系统，所以它只能在一个支持 UDF 的操作系统上使用。否则，它看"
"起来就像含有损坏的文件。要创建这种类型的 ISO 文件使用："

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:884
msgid "To create this type of ISO file:"
msgstr "创建这种类型的 ISO 文件:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:888
#, no-wrap
msgid "% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data\n"
msgstr "% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:891
msgid "To burn files directly to a disk:"
msgstr "将文件直接刻录到磁盘上："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:895
#, no-wrap
msgid "# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:898
msgid "When an ISO image already contains large files, no additional options are required for man:growisofs[1] to burn that image on a disk."
msgstr "当一个 ISO 映像已经包含大文件时，man:growisofs[1] 不需要额外的选项就可以将该映像刻录到磁盘上。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:901
msgid ""
"Be sure to use an up-to-date version of package:sysutils/cdrtools[], which contains man:mkisofs[8], as an older version may not contain large files support.  If the "
"latest version does not work, install package:sysutils/cdrtools-devel[] and read its man:mkisofs[8]."
msgstr ""
"请确保使用包含 man:mkisofs[8] 的最新版本的 package:sysutils/cdrtools[] ，因为旧版本可能不包含大文件支持。如果最新版本不能工作，请安装 package:sysutils/cdrtools-devel[] ，"
"并阅读其 man:mkisofs[8]。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:903
#, no-wrap
msgid "Burning a DVD-Video"
msgstr "刻录 DVD-Video"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:907
msgid ""
"A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF (M-UDF) specifications.  Since DVD-Video presents a specific data structure hierarchy, a "
"particular program such as package:multimedia/dvdauthor[] is needed to author the DVD."
msgstr ""
"DVD-Video 是一种基于 ISO 9660 和 micro-UDF（M-UDF） 规范的特定文件布局。由于 DVD-Video 提出了一个特定的数据结构层次，因此需要一个特定的程序，"
"如 package:multimedia/dvdauthor[] 来编写 DVD 。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:910
msgid ""
"If an image of the DVD-Video file system already exists, it can be burned in the same way as any other image.  If `dvdauthor` was used to make the DVD and the result is "
"in [.filename]#/path/to/video#, the following command should be used to burn the DVD-Video:"
msgstr ""
"如果 DVD-Video 文件系统的映像已经存在，可以用与其他映像相同的方式进行刻录。如果使用 `dvdauthor` 制作 DVD ，并且目录在 [.filename]#/path/to/video# 中，应该使用下面的命令来"
"刻录 DVD-Video："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:914
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -dvd-video /path/to/video\n"
msgstr "# growisofs -Z /dev/cd0 -dvd-video /path/to/video\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:918
msgid "`-dvd-video` is passed to man:mkisofs[8] to instruct it to create a DVD-Video file system layout.  This option implies the `-dvd-compat` man:growisofs[1] option."
msgstr "`-dvd-video` 被传递给 man:mkisofs[8] ，说明它创建一个 DVD-Video 文件系统布局。这个选项意味着 `-dvd-compat` man:growisofs[1] 选项。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:919
#, no-wrap
msgid "Using a DVD+RW"
msgstr "使用 DVD+RW"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:924
msgid ""
"Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use.  It is _recommended_ to let man:growisofs[1] take care of this automatically whenever appropriate.  "
"However, it is possible to use `dvd+rw-format` to format the DVD+RW:"
msgstr "与 CD-RW 不同，原始的 DVD+RW 在第一次使用前需要被格式化。_建议_ 让 man:growisofs[1] 自动处理这个问题。也可以使用 `dvd+rw-format` 来格式化 DVD+RW ："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:928 content/zh-cn/books/handbook/disks/_index.adoc:1018
#, no-wrap
msgid "# dvd+rw-format /dev/cd0\n"
msgstr "# dvd+rw-format /dev/cd0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:932
msgid "Only perform this operation once and keep in mind that only virgin DVD+RW medias need to be formatted.  Once formatted, the DVD+RW can be burned as usual."
msgstr "只需执行一次此操作，只有原始的 DVD+RW 介质需要被格式化。格式化之后，就可以像往常一样刻录 DVD+RW 。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:935
msgid ""
"To burn a totally new file system and not just append some data onto a DVD+RW, the media does not need to be blanked first.  Instead, write over the previous recording "
"like this:"
msgstr "要刻录一个全新的文件系统，而不仅仅是在 DVD+RW 上追加一些数据，媒体不需要先清空。而是要这样清空数据："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:939
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -J -R /path/to/newdata\n"
msgstr "# growisofs -Z /dev/cd0 -J -R /path/to/newdata\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:944
msgid ""
"The DVD+RW format supports appending data to a previous recording.  This operation consists of merging a new session to the existing one as it is not considered to be "
"multi-session writing.  man:growisofs[1] will _grow_ the ISO 9660 file system present on the media."
msgstr ""
"DVD+RW 格式支持将数据追加到以前的记录中。这个操作包括将一个新的片段合并到现有的片段上，因为它不被认为是多片段写入。man:growisofs[1] 将扩展媒体上存在的 ISO 9660 文件系统。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:946
msgid "For example, to append data to a DVD+RW, use the following:"
msgstr "例如，要向 DVD+RW 追加数据，请使用以下方法："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:950 content/zh-cn/books/handbook/disks/_index.adoc:1038
#, no-wrap
msgid "# growisofs -M /dev/cd0 -J -R /path/to/nextdata\n"
msgstr "# growisofs -M /dev/cd0 -J -R /path/to/nextdata\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:953
msgid "The same man:mkisofs[8] options used to burn the initial session should be used during next writes."
msgstr "在以后的写入过程中，应该使用与初次刻录时使用的相同的 man:mkisofs[8] 选项。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:958
msgid "Use `-dvd-compat` for better media compatibility with DVD-ROM drives.  When using DVD+RW, this option will not prevent the addition of data."
msgstr "使用 `-dvd-compat` 以获得与 DVD-ROM 驱动器更好的媒体兼容性。当使用 DVD+RW 时，这个选项不会导致数据无法添加。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:961
msgid "To blank the media, use:"
msgstr "要清空媒体，请使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:965
#, no-wrap
msgid "# growisofs -Z /dev/cd0=/dev/zero\n"
msgstr "# growisofs -Z /dev/cd0=/dev/zero\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:967
#, no-wrap
msgid "Using a DVD-RW"
msgstr "使用 DVD-RW"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:971
msgid "A DVD-RW accepts two disc formats: incremental sequential and restricted overwrite.  By default, DVD-RW discs are in sequential format."
msgstr "DVD-RW 接受两种光盘格式。顺序递增和受限覆写。默认情况下，DVD-RW 光盘使用顺序格式。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:974
msgid ""
"A virgin DVD-RW can be directly written without being formatted.  However, a non-virgin DVD-RW in sequential format needs to be blanked before writing a new initial "
"session."
msgstr "原生的 DVD-RW 可以直接写入，不需要进行格式化。然而，在写入一个新的数据之前，顺序格式的非原生 DVD-RW 需要进行清空。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:976
msgid "To blank a DVD-RW in sequential mode:"
msgstr "要清空顺序 DVD-RW 请使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:980 content/zh-cn/books/handbook/disks/_index.adoc:1025
#, no-wrap
msgid "# dvd+rw-format -blank=full /dev/cd0\n"
msgstr "# dvd+rw-format -blank=full /dev/cd0\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:987
msgid ""
"A full blanking using `-blank=full` will take about one hour on a 1x media.  A fast blanking can be performed using `-blank`, if the DVD-RW will be recorded in Disk-At-"
"Once (DAO) mode.  To burn the DVD-RW in DAO mode, use the command:"
msgstr ""
"使用 `-blank=full` 进行完全清空，在 1x 媒体上大约需要一个小时。如果 DVD-RW 将以一次性磁盘（DAO）模式刻录，可以使用 `-blank` 进行快速清空。要在 DAO 模式下刻录 DVD-RW ，请"
"使用以下命令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:991
#, no-wrap
msgid "# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso\n"
msgstr "# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:994
msgid "Since man:growisofs[1] automatically attempts to detect fast blanked media and engage DAO write, `-use-the-force-luke=dao` should not be required."
msgstr "由于 man:growisofs[1] 会自动尝试检测快速的空白介质并进行 DAO 写入，所以不需要使用 `-use-the-force-luke=dao` 。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:996
msgid "One should instead use restricted overwrite mode with any DVD-RW as this format is more flexible than the default of incremental sequential."
msgstr "任何 DVD-RW 都应该使用受限覆盖模式，因为这种格式比默认的增量顺序更灵活。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:999
msgid "To write data on a sequential DVD-RW, use the same instructions as for the other DVD formats:"
msgstr "要在连续格式的 DVD-RW 上写入数据，使用与其他 DVD 格式相同的指令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1003
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1007
msgid ""
"To append some data to a previous recording, use `-M` with man:growisofs[1].  However, if data is appended on a DVD-RW in incremental sequential mode, a new session will "
"be created on the disc and the result will be a multi-session disc."
msgstr ""
"要将一些数据追加到以前的记录中，请使用 man:growisofs[1] 的 `-M` 选项 。然而，如果在 DVD-RW 上以增量顺序模式追加数据，将在光盘上创建一个新的会话，结果将是一个多会话光盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1012
msgid ""
"A DVD-RW in restricted overwrite format does not need to be blanked before a new initial session.  Instead, overwrite the disc with `-Z`.  It is also possible to grow an "
"existing ISO 9660 file system written on the disc with `-M`.  The result will be a one-session DVD."
msgstr "在一个新的初始会话之前，限制覆盖格式的 DVD-RW 不需要清空。可以用 `-Z` 覆盖光盘。也可以用 `-M` 来扩展写在光盘上的现有 ISO 9660 文件系统。最后会是一个单会话 DVD。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1014
msgid "To put a DVD-RW in restricted overwrite format, the following command must be used:"
msgstr "要使 DVD-RW 成为限制覆盖格式，必须使用以下命令："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1021
msgid "To change back to sequential format, use:"
msgstr "要改回顺序格式，请使用:"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1027
#, no-wrap
msgid "Multi-Session"
msgstr "多会话光盘"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1032
msgid ""
"Few DVD-ROM drives support multi-session DVDs and most of the time only read the first session.  DVD+R, DVD-R and DVD-RW in sequential format can accept multiple "
"sessions.  The notion of multiple sessions does not exist for the DVD+RW and the DVD-RW restricted overwrite formats."
msgstr ""
"很少有 DVD-ROM 驱动器支持多会话的 DVD，大多数时候只能读取第一个会话。DVD+R、DVD-R 和 DVD-RW 的顺序格式可以接受多个会话。对于 DVD+RW 和 DVD-RW 限制性覆写格式，不存在多会话"
"的概念。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1034
msgid "Using the following command after an initial non-closed session on a DVD+R, DVD-R, or DVD-RW in sequential format, will add a new session to the disc:"
msgstr "在顺序格式的 DVD+R、DVD-R 或 DVD-RW 上的初始非封闭会话后，使用以下命令将在光盘上添加一个新的会话："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1043
msgid ""
"Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode will append data while merging the new session to the existing one.  The result will be a "
"single-session disc.  Use this method to add data after an initial write on these types of media."
msgstr ""
"在限制覆盖模式下对 DVD+RW 或 DVD-RW 使用这个命令，会在将新的会话合并到现有会话的同时追加数据。其结果将是一张单节光盘。使用这种方法可以在这些类型的媒体上进行初始写入后添加"
"数据。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1048
msgid ""
"Since some space on the media is used between each session to mark the end and start of sessions, one should add sessions with a large amount of data to optimize media "
"space.  The number of sessions is limited to 154 for a DVD+R, about 2000 for a DVD-R, and 127 for a DVD+R Double Layer."
msgstr ""
"由于媒体上的一些空间在每个会话之间被用来标记会话的结束和开始，所以应该尽量使用大数据会话，减少会话数量以优化媒体空间。对于 DVD+R 来说，会话的数量被限制在 154 个，对于 "
"DVD-R 来说大约是 2000 个，对于双层 DVD+R 来说是 127 个。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1050
#, no-wrap
msgid "For More Information"
msgstr "DVD 的更多信息"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1053
msgid "To obtain more information about a DVD, use `dvd+rw-mediainfo _/dev/cd0_` while the disc in the specified drive."
msgstr "要获得关于 DVD 的更多信息，使用 `dvd+rw-mediainfo /dev/cd0` ，同时在指定的驱动器中的光盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1055
msgid ""
"More information about dvd+rw-tools can be found in man:growisofs[1], on the http://fy.chalmers.se/~appro/linux/DVD+RW/[dvd+rw-tools web site], and in the http://lists."
"debian.org/cdwrite/[cdwrite mailing list] archives."
msgstr ""
"关于 dvd+rw-tools 的更多信息可以在 man:growisofs[1]、http://fy.chalmers.se/~appro/linux/DVD+RW/[dvd+rw-tools web site] "
"以及 http://lists.debian.org/cdwrite/[cdwrite mailing list] 存档中找到。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1059
msgid "When creating a problem report related to the use of dvd+rw-tools, always include the output of `dvd+rw-mediainfo`."
msgstr "当创建一个与 dvd+rw-tools 有关的问题报告时，总是包括 `dvd+rw-mediainfo` 的输出。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1062
#, no-wrap
msgid "Using a DVD-RAM"
msgstr "使用DVD-RAM"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1066
msgid ""
"DVD-RAM writers can use either a SCSI or ATAPI interface.  For ATAPI devices, DMA access has to be enabled by adding the following line to [.filename]#/boot/loader.conf#:"
msgstr "DVD-RAM写入器可以使用 SCSI 或 ATAPI 接口。对于 ATAPI 设备，必须通过在 [.filename]#/boot/loader.conf# 中添加以下一行来启用 DMA 访问："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1075
msgid ""
"A DVD-RAM can be seen as a removable hard drive.  Like any other hard drive, the DVD-RAM must be formatted before it can be used.  In this example, the whole disk space "
"will be formatted with a standard UFS2 file system:"
msgstr "DVD-RAM 可以被看作是一个可移动的硬盘驱动器。像其他硬盘一样，DVD-RAM 在使用前必须被格式化。在这个例子中，整个磁盘空间将被格式化为标准的 UFS2 文件系统："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1081
#, no-wrap
msgid ""
"# dd if=/dev/zero of=/dev/acd0 bs=2k count=1\n"
"# bsdlabel -Bw acd0\n"
"# newfs /dev/acd0\n"
msgstr ""
"# dd if=/dev/zero of=/dev/acd0 bs=2k count=1\n"
"# bsdlabel -Bw acd0\n"
"# newfs /dev/acd0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1084
msgid "The DVD device, [.filename]#acd0#, must be changed according to the configuration."
msgstr "必须根据配置改变 DVD 设备 [.filename]#acd0# 的位置。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1086
msgid "Once the DVD-RAM has been formatted, it can be mounted as a normal hard drive:"
msgstr "DVD-RAM 被格式化以后，它就可以像普通硬盘一样被挂载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1090
#, no-wrap
msgid "# mount /dev/acd0 /mnt\n"
msgstr "# mount /dev/acd0 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1093
msgid "Once mounted, the DVD-RAM will be both readable and writeable."
msgstr "安装完毕后，DVD-RAM 将可读可写。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1095
#, no-wrap
msgid "Creating and Using Floppy Disks"
msgstr "创建和使用软盘"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1098
msgid "This section explains how to format a 3.5 inch floppy disk in FreeBSD."
msgstr "这一节解释了如何在 FreeBSD 中格式化 3.5 英寸软盘。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1102
#, no-wrap
msgid "*Procedure: Steps to Format a Floppy*\n"
msgstr "*程序：格式化软盘的步骤*\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1107
msgid ""
"A floppy disk needs to be low-level formatted before it can be used.  This is usually done by the vendor, but formatting is a good way to check media integrity.  To low-"
"level format the floppy disk on FreeBSD, use man:fdformat[1].  When using this utility, make note of any error messages, as these can help determine if the disk is good "
"or bad."
msgstr ""
"软盘在使用前需要进行低级格式化。这通常是由供应商完成的，但格式化是检查介质完整性的一个好方法。要在 FreeBSD 上对软盘进行低级别的格式化，可以使用 man:fdformat[1]。当使用这"
"个工具时，注意任何错误信息，因为这些信息可以帮助确定磁盘是好是坏。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1109
msgid "To format the floppy, insert a new 3.5 inch floppy disk into the first floppy drive and issue:"
msgstr "要格式化软盘，将一张新的 3.5 英寸软盘插入第一个软盘驱动器并使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1113
#, no-wrap
msgid "# /usr/sbin/fdformat -f 1440 /dev/fd0\n"
msgstr "# /usr/sbin/fdformat -f 1440 /dev/fd0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1116
msgid ""
"After low-level formatting the disk, create a disk label as it is needed by the system to determine the size of the disk and its geometry. The supported geometry values "
"are listed in [.filename]#/etc/disktab#."
msgstr "在低级格式化后，创建一个磁盘标签，因为系统需要它来确定磁盘的大小和它的几何形状。支持的几何值在 [.filename]#/etc/disktab# 中列出。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1118
msgid "To write the disk label, use man:bsdlabel[8]:"
msgstr "要写入磁盘标签，请使用 man:bsdlabel[8]："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1122
#, no-wrap
msgid "# /sbin/bsdlabel -B -w /dev/fd0 fd1440\n"
msgstr "# /sbin/bsdlabel -B -w /dev/fd0 fd1440\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1125
msgid ""
"The floppy is now ready to be high-level formatted with a file system. The floppy's file system can be either UFS or FAT, where FAT is generally a better choice for "
"floppies."
msgstr "现在，软盘已经准备好用文件系统进行高级格式化。软盘的文件系统可以是 UFS 或 FAT ，其中 FAT 通常是更好选择。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1127
msgid "To format the floppy with FAT, issue:"
msgstr "要用 FAT 格式化软盘，请使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1131
#, no-wrap
msgid "# /sbin/newfs_msdos /dev/fd0\n"
msgstr "# /sbin/newfs_msdos /dev/fd0\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1137
msgid ""
"The disk is now ready for use.  To use the floppy, mount it with man:mount_msdosfs[8].  One can also install and use package:emulators/mtools[] from the Ports Collection."
msgstr "现在，该磁盘已经可以使用了。要使用软盘，用 man:mount_msdosfs[8] 挂载它。我们还可以安装和使用 Ports Collection 中的 package:emulators/mtools[]。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1139
#, no-wrap
msgid "Using NTFS Disks"
msgstr "使用 NTFS 磁盘"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1142
msgid "This section explains how to mount NTFS disks in FreeBSD."
msgstr "这一节解释了如何在 FreeBSD 中挂载 NTFS 磁盘。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1147
msgid ""
"NTFS (New Technology File System) is a proprietary journaling file system developed by Microsoft(R).  It has been the default file system in Microsoft Windows(R) for "
"many years.  FreeBSD can mount NTFS volumes using a FUSE file system.  These file systems are implemented as user space programs which interact with the man:fusefs[5] "
"kernel module via a well defined interface."
msgstr ""
"NTFS（新技术文件系统）是一个由 Microsoft(R) 开发的专有日志文件系统。多年来，它一直是 Microsoft Windows(R) 的默认文件系统。FreeBSD 可以使用 FUSE 文件系统挂载 NTFS 卷。这些"
"文件系统是作为用户空间程序实现的，它通过一个定义好的接口与 man:fusefs[5] 内核模块交互。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1151
#, no-wrap
msgid "*Procedure: Steps to Mount a NTFS Disk*\n"
msgstr "*程序：挂载 NTFS 磁盘的步骤*\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1154
msgid "Before using a FUSE file system we need to load the man:fusefs[5] kernel module:"
msgstr "在使用 FUSE 文件系统之前，我们需要加载 man:fusefs[5] 内核模块："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1158
#, no-wrap
msgid "# kldload fusefs\n"
msgstr "# kldload fusefs\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1161
msgid "Use man:sysrc[8] to load the module at startup:"
msgstr "使用 man:sysrc[8] 在启动时加载该模块："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1165
#, no-wrap
msgid "# sysrc kld_list+=fusefs\n"
msgstr "# sysrc kld_list+=fusefs\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1168
msgid ""
"Install the actual NTFS file system from packages as in the example (see crossref:ports[pkgng-intro,Using pkg for Binary Package Management]) or from ports (see crossref:"
"ports[ports-using,Using the Ports Collection]):"
msgstr "像例子中那样从包中安装 NTFS 文件系统（参见 crossref:ports[pkgng-intro,使用 行二进制包管理]或从 ports（参见 crossref:ports[ports-using, 使用ports]）："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1172
#, no-wrap
msgid "# pkg install fusefs-ntfs\n"
msgstr "# pkg install fusefs-ntfs\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1175
msgid "Last we need to create a directory where the file system will be mounted:"
msgstr "最后，我们需要创建一个文件系统挂载的目录："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1179
#, no-wrap
msgid "# mkdir /mnt/usb\n"
msgstr "# mkdir /mnt/usb\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1182
msgid "Suppose a USB disk is plugged in.  The disk partition information can be viewed with man:gpart[8]:"
msgstr "假设一个 USB 磁盘被插上了。可以用 man:gpart[8] 查看磁盘的分区信息："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1188
#, no-wrap
msgid ""
"# gpart show da0\n"
"=>\t  63  1953525105  da0 MBR   (932G)\n"
"\t  63  1953525105    1 ntfs  (932G)\n"
msgstr ""
"# gpart show da0\n"
"=>\t  63  1953525105  da0 MBR   (932G)\n"
"\t  63  1953525105    1 ntfs  (932G)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1191
msgid "We can mount the disk using the following command:"
msgstr "可以用下面的命令挂载该磁盘:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1195
#, no-wrap
msgid "# ntfs-3g /dev/da0s1 /mnt/usb/\n"
msgstr "# ntfs-3g /dev/da0s1 /mnt/usb/\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1197
msgid "The disk is now ready to use."
msgstr "现在，该磁盘已经可以使用了。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1199
msgid "Additionally, an entry can be added to /etc/fstab:"
msgstr "此外，可以在 /etc/fstab 中添加一个条目："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1203
#, no-wrap
msgid "/dev/da0s1  /mnt/usb\tntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0\n"
msgstr "/dev/da0s1  /mnt/usb\tntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1206
msgid "Now the disk can be now mounted with:"
msgstr "现在，该磁盘现在可以被挂载了："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1210
#, no-wrap
msgid "# mount /mnt/usb\n"
msgstr "# mount /mnt/usb\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1213
msgid "The disk can be unmounted with:"
msgstr "磁盘可以通过以下方式卸载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1217
#, no-wrap
msgid "# umount /mnt/usb/\n"
msgstr "# umount /mnt/usb/\n"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1221
#, no-wrap
msgid "Backup Basics"
msgstr "备份基础"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1224
msgid ""
"Implementing a backup plan is essential in order to have the ability to recover from disk failure, accidental file deletion, random file corruption, or complete machine "
"destruction, including destruction of on-site backups."
msgstr "为了有能力从磁盘故障、意外文件删除、随机文件损坏或机器完全毁坏（包括现场备份的毁坏）中恢复，实施一个备份计划是至关重要的。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1227
msgid ""
"The backup type and schedule will vary, depending upon the importance of the data, the granularity needed for file restores, and the amount of acceptable downtime.  Some "
"possible backup techniques include:"
msgstr "备份类型和时间表将有所不同，这取决于数据的重要性、文件恢复所需的粒度以及可接受的停机时间的多少。一些可能的备份技术包括："

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1229
msgid ""
"Archives of the whole system, backed up onto permanent, off-site media. This provides protection against all of the problems listed above, but is slow and inconvenient "
"to restore from, especially for non-privileged users."
msgstr "整个系统的档案，备份到永久的、异地的媒体上。这提供了对上述所有问题的保护，但恢复起来很慢而且不方便，特别是对非特权用户。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1230
msgid "File system snapshots, which are useful for restoring deleted files or previous versions of files."
msgstr "文件系统快照，这对恢复已删除的文件或以前的文件版本很有用。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1231
msgid "Copies of whole file systems or disks which are synchronized with another system on the network using a scheduled package:net/rsync[]."
msgstr "整个文件系统或磁盘的副本，使用预定的 package:net/rsync[] 与网络上的另一个系统同步。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1232
msgid "Hardware or software RAID, which minimizes or avoids downtime when a disk fails."
msgstr "硬件或软件 RAID，当一个磁盘发生故障时，可以最大限度地减少或避免停机。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1236
msgid ""
"Typically, a mix of backup techniques is used.  For example, one could create a schedule to automate a weekly, full system backup that is stored off-site and to "
"supplement this backup with hourly ZFS snapshots.  In addition, one could make a manual backup of individual directories or files before making file edits or deletions."
msgstr ""
"通常情况下，要混合使用各种备份技术。例如，人们可以创建一个时间表，自动进行每周一次的全系统备份，并将其存放在异地，同时用每小时的 ZFS 快照来补充这一备份。此外，在进行文件"
"编辑或删除之前，可以对个别目录或文件进行手动备份。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1238
msgid "This section describes some of the utilities which can be used to create and manage backups on a FreeBSD system."
msgstr "这一节描述了一些可以用来创建和管理 FreeBSD 系统上的备份的实用程序。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1239
#, no-wrap
msgid "File System Backups"
msgstr "文件系统备份"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1245
msgid ""
"The traditional UNIX(R) programs for backing up a file system are man:dump[8], which creates the backup, and man:restore[8], which restores the backup.  These utilities "
"work at the disk block level, below the abstractions of the files, links, and directories that are created by file systems.  Unlike other backup software, `dump` backs "
"up an entire file system and is unable to backup only part of a file system or a directory tree that spans multiple file systems.  Instead of writing files and "
"directories, `dump` writes the raw data blocks that comprise files and directories."
msgstr ""
"用于备份文件系统的传统 UNIX(R) 程序是 man:dump[8] 和 man:restore[8] ，前者用于创建备份，后者用于恢复备份。这些工具在磁盘块级工作，低于文件系统所创建的文件、链接和目录的抽"
"象性。与其他备份软件不同，`dump` 备份的是整个文件系统，不能只备份一个文件系统的一部分或跨越多个文件系统的目录树。`dump` 不是写文件和目录，而是写构成文件和目录的原始数据"
"块。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1249
msgid ""
"If `dump` is used on the root directory, it will not back up [.filename]#/home#, [.filename]#/usr# or many other directories since these are typically mount points for "
"other file systems or symbolic links into those file systems."
msgstr "如果在根目录上使用 `dump` ，它将不会备份 [.filename]#/home#、[.filename]#/usr# 或许多其他目录，因为这些目录通常是其他文件系统的挂载点或这些文件系统的符号链接。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1253
msgid ""
"When used to restore data, `restore` stores temporary files in [.filename]#/tmp/# by default.  When using a recovery disk with a small [.filename]#/tmp#, set `TMPDIR` to "
"a directory with more free space in order for the restore to succeed."
msgstr ""
"当用于恢复数据时，`restore` 默认在 [.filename]#/tmp/# 中存储临时文件。当使用 [.filename]#/tmp# 较小的恢复盘时，请将 `TMPDIR` 设置为一个有更多自由空间的目录，以便恢复成"
"功。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1257
msgid ""
"When using `dump`, be aware that some quirks remain from its early days in Version 6 of AT&T UNIX(R),circa 1975.  The default parameters assume a backup to a 9-track "
"tape, rather than to another type of media or to the high-density tapes available today.  These defaults must be overridden on the command line."
msgstr ""
"当使用 `dump` 时，请注意它在 1975 年左右的 AT&T UNIX(R) 第 6 版中的一些问题仍然存在。默认参数假定备份到 9 轨磁带，而不是备份到其他类型的媒体或今天可用的高密度磁带上。这些"
"默认值必须在命令行中被覆盖。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1260
msgid ""
"It is possible to backup a file system across the network to a another system or to a tape drive attached to another computer.  While the man:rdump[8] and man:"
"rrestore[8] utilities can be used for this purpose, they are not considered to be secure."
msgstr "可以通过网络将一个文件系统备份到另一个系统或连接到另一台计算机的磁带驱动器。虽然 man:rdump[8] 和 man:rrestore[8] 工具可以用于这个目的，但它们被认为是不安全的。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1263
msgid ""
"Instead, one can use `dump` and `restore` in a more secure fashion over an SSH connection.  This example creates a full, compressed backup of [.filename]#/usr# and sends "
"the backup file to the specified host over a SSH connection."
msgstr ""
"相反，我们可以通过SSH连接，以更安全的方式使用 `dump` 和 `restore` 。这个例子创建了一个 [.filename]#/usr# 的完整压缩备份，并通过 SSH 连接将备份文件发送到指定的主机上:"

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1264
#, no-wrap
msgid "Using `dump` over ssh"
msgstr "通过 SSH 使用 `dump`"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1271
#, no-wrap
msgid ""
"# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \\\n"
"          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz\n"
msgstr ""
"# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \\\n"
"          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1275
msgid "This example sets `RSH` in order to write the backup to a tape drive on a remote system over a SSH connection:"
msgstr "这个例子设置了 `RSH` ，以便通过 SSH 连接将备份写到远程系统的磁带机上："

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1276
#, no-wrap
msgid "Using `dump` over ssh with `RSH` Set"
msgstr "使用 `RSH` 集通过 `ssh` 转储"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1282
#, no-wrap
msgid "# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr\n"
msgstr "# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1285
#, no-wrap
msgid "Directory Backups"
msgstr "目录备份"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1288
msgid "Several built-in utilities are available for backing up and restoring specified files and directories as needed."
msgstr "有几个内置的工具可用于根据需要备份和恢复指定的文件和目录。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1292
msgid ""
"A good choice for making a backup of all of the files in a directory is man:tar[1].  This utility dates back to Version 6 of AT&T UNIX(R) and by default assumes a "
"recursive backup to a local tape device.  Switches can be used to instead specify the name of a backup file."
msgstr ""
"man:tar[1] 是对一个目录中所有文件进行备份的好选择。这个工具可以追溯到 AT&T UNIX(R) 的第 6 版，默认情况下，它假定是递归备份到本地磁带设备。可以用开关来代替指定备份文件的名"
"称。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1295
msgid ""
"This example creates a compressed backup of the current directory and saves it to [.filename]#/tmp/mybackup.tgz#.  When creating a backup file, make sure that the backup "
"is not saved to the same directory that is being backed up."
msgstr "这个例子创建了一个当前目录的压缩备份，并将其保存到 [.filename]#/tmp/mybackup.tgz# 。当创建一个备份文件时，要确保备份不保存在被备份的同一目录下："

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1296
#, no-wrap
msgid "Backing Up the Current Directory with `tar`"
msgstr "用 `tar` 备份当前目录"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1302
#, no-wrap
msgid "# tar czvf /tmp/mybackup.tgz .\n"
msgstr "# tar czvf /tmp/mybackup.tgz .\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1308
msgid ""
"To restore the entire backup, `cd` into the directory to restore into and specify the name of the backup.  Note that this will overwrite any newer versions of files in "
"the restore directory.  When in doubt, restore to a temporary directory or specify the name of the file within the backup to restore."
msgstr ""
"要恢复整个备份，`cd` 进入要恢复的目录并指定备份的名称。注意，这将覆盖还原目录中任何较新版本的文件。如有疑问，可将其还原到一个临时目录或指定要还原的备份中的文件名称："

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1309
#, no-wrap
msgid "Restoring Up the Current Directory with `tar`"
msgstr "用 `tar` 恢复当前目录"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1315
#, no-wrap
msgid "# tar xzvf /tmp/mybackup.tgz\n"
msgstr "# tar xzvf /tmp/mybackup.tgz\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1320
msgid ""
"There are dozens of available switches which are described in man:tar[1].  This utility also supports the use of exclude patterns to specify which files should not be "
"included when backing up the specified directory or restoring files from a backup."
msgstr "在 man:tar[1] 中有几十个可用的开关。这个工具还支持使用排除模式来指定在备份指定目录或从备份中恢复文件时不应该包括哪些文件。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1323
msgid ""
"To create a backup using a specified list of files and directories, man:cpio[1] is a good choice.  Unlike `tar`, `cpio` does not know how to walk the directory tree and "
"it must be provided the list of files to backup."
msgstr "要使用指定的文件和目录列表来创建备份，man:cpio[1] 是一个不错的选择。与 `tar` 不同，`cpio` 不知道如何进入目录树，它必须被提供要备份的文件列表。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1326
msgid ""
"For example, a list of files can be created using `ls` or `find`.  This example creates a recursive listing of the current directory which is then piped to `cpio` in "
"order to create an output backup file named [.filename]#/tmp/mybackup.cpio#."
msgstr ""
"例如，可以用 `ls` 或 `find` 创建一个文件列表。这个例子创建了一个当前目录的递归列表，然后被输送到 `cpio` ，以便创建一个名为 [.filename]#/tmp/mybackup.cpio# 的输出备份文件:"

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1327
#, no-wrap
msgid "Using `ls` and `cpio` to Make a Recursive Backup of the Current Directory"
msgstr "使用 `ls` 和 `cpio` 对当前目录进行递归备份"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1333
#, no-wrap
msgid "# ls -R | cpio -ovF /tmp/mybackup.cpio\n"
msgstr "# ls -R | cpio -ovF /tmp/mybackup.cpio\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1339
msgid ""
"A backup utility which tries to bridge the features provided by `tar` and `cpio` is man:pax[1].  Over the years, the various versions of `tar` and `cpio` became slightly "
"incompatible.  POSIX(R) created `pax` which attempts to read and write many of the various `cpio` and `tar` formats, plus new formats of its own."
msgstr ""
"man:pax[1] 是一个试图结合 `tar` 和 `cpio` 所提供功能的备份工具。多年来，不同版本的 `tar` 和 `cpio` 变得有些不兼容。POSIX(R) 创造了 `pax` ，它试图读写许多不同的 `cpio` 和 "
"`tar` 格式，加上自己的新格式。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1341
msgid "The `pax` equivalent to the previous examples would be:"
msgstr "前面的例子在使用 `pax` 时等效为："

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1342
#, no-wrap
msgid "Backing Up the Current Directory with `pax`"
msgstr "用 `pax` 备份当前目录"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1348
#, no-wrap
msgid "# pax -wf /tmp/mybackup.pax .\n"
msgstr "# pax -wf /tmp/mybackup.pax .\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1352
#, no-wrap
msgid "Using Data Tapes for Backups"
msgstr "使用数据磁带进行备份"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1357
msgid ""
"While tape technology has continued to evolve, modern backup systems tend to combine off-site backups with local removable media.  FreeBSD supports any tape drive that "
"uses SCSI, such as LTO or DAT.  There is limited support for SATA and USB tape drives."
msgstr ""
"在磁带技术不断发展的同时，现代的备份系统倾向于将异地备份与本地可移动媒体相结合。FreeBSD 支持任何使用 SCSI 的磁带机，如 LTO 或 DAT。对 SATA 和 USB 磁带机的支持是有限的。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1361
msgid ""
"For SCSI tape devices, FreeBSD uses the man:sa[4] driver and the [.filename]#/dev/sa0#, [.filename]#/dev/nsa0#, and [.filename]#/dev/esa0# devices.  The physical device "
"name is [.filename]#/dev/sa0#. When [.filename]#/dev/nsa0# is used, the backup application will not rewind the tape after writing a file, which allows writing more than "
"one file to a tape.  Using [.filename]#/dev/esa0# ejects the tape after the device is closed."
msgstr ""
"对于 SCSI 磁带设备，FreeBSD 使用 man:sa[4] 驱动程序和 [.filename]#/dev/sa0#、[.filename]#/dev/nsa0# 和 [.filename]#/dev/esa0# 。物理设备的名字是 [.filename]#/dev/sa0#。当"
"使用 [.filename]#/dev/nsa0# 时，备份程序在写完一个文件后不会倒带，这就允许在一盘磁带上写多个文件。使用 [.filename]#/dev/esa0# 会在设备关闭后弹出磁带。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1364
msgid ""
"In FreeBSD, `mt` is used to control operations of the tape drive, such as seeking through files on a tape or writing tape control marks to the tape.  For example, the "
"first three files on a tape can be preserved by skipping past them before writing a new file:"
msgstr "在 FreeBSD 中，`mt` 被用来控制磁带机的操作，例如在磁带上寻找文件或向磁带上写入磁带控制标记。例如，在写一个新的文件之前，可以通过跳过它们来保留磁带上的前三个文件："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1368
#, no-wrap
msgid "# mt -f /dev/nsa0 fsf 3\n"
msgstr "# mt -f /dev/nsa0 fsf 3\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1371
msgid "This utility supports many operations. Refer to man:mt[1] for details."
msgstr "这个工具支持许多操作。详情请参考 man:mt[1]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1373
msgid "To write a single file to tape using `tar`, specify the name of the tape device and the file to backup:"
msgstr "要用 `tar` 写一个文件到磁带，指定磁带设备的名称和要备份的文件："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1377
#, no-wrap
msgid "# tar cvf /dev/sa0 file\n"
msgstr "# tar cvf /dev/sa0 file\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1380
msgid "To recover files from a `tar` archive on tape into the current directory:"
msgstr "要从磁带上的 `tar` 存档中恢复文件到当前目录："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1384
#, no-wrap
msgid "# tar xvf /dev/sa0\n"
msgstr "# tar xvf /dev/sa0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1388
msgid "To backup a UFS file system, use `dump`.  This examples backs up [.filename]#/usr# without rewinding the tape when finished:"
msgstr "要备份一个 UFS 文件系统，使用 `dump` 。这个例子备份了 [.filename]#/usr# ，完成后没有倒带："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1392
#, no-wrap
msgid "# dump -0aL -b64 -f /dev/nsa0 /usr\n"
msgstr "# dump -0aL -b64 -f /dev/nsa0 /usr\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1395
msgid "To interactively restore files from a `dump` file on tape into the current directory:"
msgstr "以交互方式将文件从磁带上的转储文件恢复到当前目录："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1399
#, no-wrap
msgid "# restore -i -f /dev/nsa0\n"
msgstr "# restore -i -f /dev/nsa0\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1402
#, no-wrap
msgid "Third-Party Backup Utilities"
msgstr "第三方备份工具"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1406
msgid ""
"The FreeBSD Ports Collection provides many third-party utilities which can be used to schedule the creation of backups, simplify tape backup, and make backups easier and "
"more convenient.  Many of these applications are client/server based and can be used to automate the backups of a single system or all of the computers in a network."
msgstr ""
"FreeBSD Ports Collection 提供了许多第三方的实用程序，它们可以用来安排备份的创建，简化磁带备份，并使备份更容易和更方便。这些应用程序中有许多是基于客户/服务器的，可以用来自"
"动备份单个系统或网络中的所有计算机。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1408
msgid "Popular utilities include Amanda, Bacula, rsync, and duplicity."
msgstr "流行的实用程序包括 Amanda 、Bacula 、rsync 和 duplicity 。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1409
#, no-wrap
msgid "Emergency Recovery"
msgstr "紧急恢复"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1412
msgid "In addition to regular backups, it is recommended to perform the following steps as part of an emergency preparedness plan."
msgstr "除了定期备份外，建议执行以下步骤作为应急准备计划的一部分。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1414
msgid "Create a print copy of the output of the following commands:"
msgstr "为以下命令的输出创建一个打印副本："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1416
msgid "`gpart show`"
msgstr "`gpart show`"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1417
msgid "`more /etc/fstab`"
msgstr "`more /etc/fstab`"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1418
msgid "`dmesg`"
msgstr "`dmesg`"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1422
msgid ""
"Store this printout and a copy of the installation media in a secure location.  Should an emergency restore be needed, boot into the installation media and select `Live "
"CD` to access a rescue shell.  This rescue mode can be used to view the current state of the system, and if needed, to reformat disks and restore data from backups."
msgstr ""
"把这个打印结果和安装介质的副本保存在一个安全的地方。如果需要紧急恢复，请启动安装介质并选择 `Live CD` 来访问一个救援 shell 。这个救援模式可以用来查看系统的当前状态，如果需"
"要，可以重新格式化磁盘并从备份中恢复数据。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1427
msgid ""
"The installation media for FreeBSD/i386 {rel112-current}-RELEASE does not include a rescue shell.  For this version, instead download and burn a Livefs CD image from "
"link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/"
"releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso]."
msgstr ""
"FreeBSD/i386 {rel112-current}-RELEASE 的安装介质不包括救援 shell 。对于这个版本，请从以下地址下载并刻录Livefs CD镜像： link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/"
"i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-"
"{rel112-current}-RELEASE-i386-livefs.iso]."

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1433
msgid ""
"Next, test the rescue shell and the backups.  Make notes of the procedure.  Store these notes with the media, the printouts, and the backups.  These notes may prevent "
"the inadvertent destruction of the backups while under the stress of performing an emergency recovery."
msgstr "接下来，测试救援 shell 和备份。对该过程做记录。将这些笔记与介质、打印件和备份一起保存。这些记录可以防止在执行紧急恢复的压力下不小心破坏了备份。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1435
msgid ""
"For an added measure of security, store the latest backup at a remote location which is physically separated from the computers and disk drives by a significant distance."
msgstr "为了增加安全性，将最新的备份存放在一个与计算机和磁盘驱动器相隔很远的远程位置。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1437
#, no-wrap
msgid "Memory Disks"
msgstr "内存盘"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1441
msgid ""
"In addition to physical disks, FreeBSD also supports the creation and use of memory disks.  One possible use for a memory disk is to access the contents of an ISO file "
"system without the overhead of first burning it to a CD or DVD, then mounting the CD/DVD media."
msgstr "除了物理磁盘之外，FreeBSD 还支持创建和使用内存盘。内存盘的一个可能用途是访问 ISO 文件系统的内容，而不需要先将其刻录再挂载 CD 或 DVD 。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1445
msgid ""
"In FreeBSD, the man:md[4] driver is used to provide support for memory disks.  The [.filename]#GENERIC# kernel includes this driver.  When using a custom kernel "
"configuration file, ensure it includes this line:"
msgstr "在 FreeBSD 中，man:md[4] 驱动程序被用来提供对内存盘的支持。[.filename]#GENERIC# 内核包括这个驱动。当使用一个自定义的内核配置文件时，请确保它包括这一行:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1449
#, no-wrap
msgid "device md\n"
msgstr "device md\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1452
#, no-wrap
msgid "Attaching and Detaching Existing Images"
msgstr "附加和分离现有的映像"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1458
msgid ""
"To mount an existing file system image, use `mdconfig` to specify the name of the ISO file and a free unit number.  Then, refer to that unit number to mount it on an "
"existing mount point.  Once mounted, the files in the ISO will appear in the mount point.  This example attaches _diskimage.iso_ to the memory device [.filename]#/dev/"
"md0# then mounts that memory device on [.filename]#/mnt#:"
msgstr ""
"要挂载一个现有的文件系统映像，使用 `mdconfig` 来指定 ISO 文件的名称和一个空闲单元号。然后，参考该单元号将其挂载到一个现有的挂载点上。挂载成功后，ISO 中的文件将出现在挂载"
"点中。这个例子将 _diskimage.iso_ 附加到内存设备 [.filename]#/dev/md0# ，然后将该内存设备挂载到 [.filename]#/mnt#："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1463
#, no-wrap
msgid ""
"# mdconfig -f diskimage.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"
msgstr ""
"# mdconfig -f diskimage.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1468
msgid ""
"Notice that `-t cd9660` was used to mount an ISO format.  If a unit number is not specified with `-u`, `mdconfig` will automatically allocate an unused memory device and "
"output the name of the allocated unit, such as [.filename]#md4#.  Refer to man:mdconfig[8] for more details about this command and its options."
msgstr ""
"注意，`-t cd9660` 被用来挂载一个ISO 格式。如果没有用 `-u` 指定单元号，`mdconfig` 将自动分配一个未使用的内存设备，并输出分配单元的名称，如 [.filename]#md4# 。关于这个命令"
"及其选项的更多细节，请参考 man:mdconfig[8]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1472
msgid ""
"When a memory disk is no longer in use, its resources should be released back to the system.  First, unmount the file system, then use `mdconfig` to detach the disk from "
"the system and release its resources.  To continue this example:"
msgstr "当一个内存盘不再被使用时，它的资源应该被释放回系统中。首先，卸载文件系统，然后使用 `mdconfig` 将磁盘从系统中分离出来并释放其资源。继续这个例子:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1477
#, no-wrap
msgid ""
"# umount /mnt\n"
"# mdconfig -d -u 0\n"
msgstr ""
"# umount /mnt\n"
"# mdconfig -d -u 0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1480
msgid "To determine if any memory disks are still attached to the system, type `mdconfig -l`."
msgstr "要确定是否有任何内存盘仍然连接在系统上，键入 `mdconfig -l`。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1482
#, no-wrap
msgid "Creating a File- or Memory-Backed Memory Disk"
msgstr "创建一个以文件或内存为基础的内存盘"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1487
msgid ""
"FreeBSD also supports memory disks where the storage to use is allocated from either a hard disk or an area of memory.  The first method is commonly referred to as a "
"file-backed file system and the second method as a memory-backed file system.  Both types can be created using `mdconfig`."
msgstr ""
"FreeBSD 也支持内存磁盘，其中使用的存储空间是从硬盘或内存区域中分配的。第一种方法通常被称为文件支持的文件系统，第二种方法被称为内存支持的文件系统。这两种类型都可以用 "
"`mdconfig` 来创建。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1492
msgid ""
"To create a new memory-backed file system, specify a type of `swap` and the size of the memory disk to create.  Then, format the memory disk with a file system and mount "
"as usual.  This example creates a 5M memory disk on unit `1`.  That memory disk is then formatted with the UFS file system before it is mounted:"
msgstr ""
"要创建一个新的内存支持的文件系统，指定 `swap` 类型和要创建的内存盘的大小。然后，用文件系统格式化内存盘，像往常一样挂载。这个例子在单元 `1` 上创建了一个 5M 的内存盘。然后"
"在挂载前用 UFS 文件系统格式化该内存盘:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1506
#, no-wrap
msgid ""
"# mdconfig -a -t swap -s 5m -u 1\n"
"# newfs -U md1\n"
"/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.\n"
"        with soft updates\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2752, 5344, 7936\n"
"# mount /dev/md1 /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md1        4718    4  4338     0%    /mnt\n"
msgstr ""
"# mdconfig -a -t swap -s 5m -u 1\n"
"# newfs -U md1\n"
"/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.\n"
"        with soft updates\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2752, 5344, 7936\n"
"# mount /dev/md1 /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md1        4718    4  4338     0%    /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1510
msgid "To create a new file-backed memory disk, first allocate an area of disk to use.  This example creates an empty 5MB file named [.filename]#newimage#:"
msgstr "要创建一个新的以文件为基础的内存磁盘，首先要分配一个磁盘区域来使用。这个例子创建了一个 5MB 的空文件，名为 [.filename]#newimage#:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1516
#, no-wrap
msgid ""
"# dd if=/dev/zero of=newimage bs=1k count=5k\n"
"5120+0 records in\n"
"5120+0 records out\n"
msgstr ""
"# dd if=/dev/zero of=newimage bs=1k count=5k\n"
"5120+0 records in\n"
"5120+0 records out\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1519
msgid ""
"Next, attach that file to a memory disk, label the memory disk and format it with the UFS file system, mount the memory disk, and verify the size of the file-backed disk:"
msgstr "接下来，将该文件附加到一个存储盘上，给存储盘贴上标签，并用 UFS 文件系统对其进行格式化，挂载存储盘，并验证该文件支持的磁盘的大小:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1533
#, no-wrap
msgid ""
"# mdconfig -f newimage -u 0\n"
"# bsdlabel -w md0 auto\n"
"# newfs -U md0a\n"
"/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2720, 5280, 7840\n"
"# mount /dev/md0a /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md0a       4710    4  4330     0%    /mnt\n"
msgstr ""
"# mdconfig -f newimage -u 0\n"
"# bsdlabel -w md0 auto\n"
"# newfs -U md0a\n"
"/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2720, 5280, 7840\n"
"# mount /dev/md0a /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md0a       4710    4  4330     0%    /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1538
msgid ""
"It takes several commands to create a file- or memory-backed file system using `mdconfig`.  FreeBSD also comes with `mdmfs` which automatically configures a memory disk, "
"formats it with the UFS file system, and mounts it.  For example, after creating _newimage_ with `dd`, this one command is equivalent to running the `bsdlabel`, `newfs`, "
"and `mount` commands shown above:"
msgstr ""
"使用 `mdconfig` 创建一个文件或内存支持的文件系统需要几个命令。FreeBSD 还配备了 `mdmfs` ，它可以自动配置一个内存盘，用 UFS 文件系统格式化，并挂载它。例如，在用 dd 创建 "
"_newimage_ 之后，这条命令就相当于运行上面的 `bsdlabel` 、 `newfs` 和 `mount` 命令:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1542
#, no-wrap
msgid "# mdmfs -F newimage -s 5m md0 /mnt\n"
msgstr "# mdmfs -F newimage -s 5m md0 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1545
msgid "To instead create a new memory-based memory disk with `mdmfs`, use this one command:"
msgstr "要使用 `mdmfs` 创建一个新的基于内存的内存磁盘，请使用以下命令:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1549
#, no-wrap
msgid "# mdmfs -s 5m md1 /mnt\n"
msgstr "# mdmfs -s 5m md1 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1553
msgid "If the unit number is not specified, `mdmfs` will automatically select an unused memory device.  For more details about `mdmfs`, refer to man:mdmfs[8]."
msgstr "如果没有指定单元号，`mdmfs` 将自动选择一个未使用的内存设备。关于 `mdmfs` 的更多细节，请参考 man:mdmfs[8] 。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1555
#, no-wrap
msgid "File System Snapshots"
msgstr "文件系统快照"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1558
msgid "FreeBSD offers a feature in conjunction with crossref:config[soft-updates,Soft Updates]: file system snapshots."
msgstr "FreeBSD 提供了一个与 crossref:config[soft-updates,软更新] 相结合的功能：文件系统快照。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1564
msgid ""
"UFS snapshots allow a user to create images of specified file systems, and treat them as a file.  Snapshot files must be created in the file system that the action is "
"performed on, and a user may create no more than 20 snapshots per file system.  Active snapshots are recorded in the superblock so they are persistent across unmount and "
"remount operations along with system reboots.  When a snapshot is no longer required, it can be removed using man:rm[1].  While snapshots may be removed in any order, "
"all the used space may not be acquired because another snapshot will possibly claim some of the released blocks."
msgstr ""
"UFS 快照允许用户创建指定文件系统的映像，并将其视为一个文件。快照文件必须在执行该操作的文件系统中创建，并且用户可以在每个文件系统中创建不超过 20 个快照。活动快照被记录在超"
"级区块中，因此它们在卸载和重挂操作以及系统重启时都是持久的。当快照不再需要时，可以用 man:rm[1] 删除它。虽然快照可以以任何顺序被移除，但所有使用过的空间可能不会被获取，因"
"为另一个快照可能会需要一些被释放的块。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1567
msgid ""
"The un-alterable `snapshot` file flag is set by man:mksnap_ffs[8] after initial creation of a snapshot file.  man:unlink[1] makes an exception for snapshot files since "
"it allows them to be removed."
msgstr "不可更改的快照文件标志是由 man:mksnap_ffs[8] 在最初创建快照文件后设置的。man:unlink[1] 对快照文件做了例外处理，因为它允许它们被删除。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1570
msgid "Snapshots are created using man:mount[8].  To place a snapshot of [.filename]#/var# in the file [.filename]#/var/snapshot/snap#, use the following command:"
msgstr "快照通过 man:mount[8] 创建。要把 [.filename]#/var# 的快照放在 [.filename]#/var/snapshot/snap# 文件中，使用下面的命令:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1574
#, no-wrap
msgid "# mount -u -o snapshot /var/snapshot/snap /var\n"
msgstr "# mount -u -o snapshot /var/snapshot/snap /var\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1577
msgid "Alternatively, use man:mksnap_ffs[8] to create the snapshot:"
msgstr "或者使用 man:mksnap_ffs[8] 来创建快照:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1581
#, no-wrap
msgid "# mksnap_ffs /var /var/snapshot/snap\n"
msgstr "# mksnap_ffs /var /var/snapshot/snap\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1584
msgid "One can find snapshot files on a file system, such as [.filename]#/var#, using man:find[1]:"
msgstr "可以使用 man:find[1] 在文件系统上找到快照文件，例如 [.filename]#/var#:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1588
#, no-wrap
msgid "# find /var -flags snapshot\n"
msgstr "# find /var -flags snapshot\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1591
msgid "Once a snapshot has been created, it has several uses:"
msgstr "创建的快照，它有几种用途："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1593
msgid "Some administrators will use a snapshot file for backup purposes, because the snapshot can be transferred to CDs or tape."
msgstr "一些管理员会将快照文件用于备份目的，因为快照可以被传输到 CD 或磁带。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1594
msgid ""
"The file system integrity checker, man:fsck[8], may be run on the snapshot. Assuming that the file system was clean when it was mounted, this should always provide a "
"clean and unchanging result."
msgstr "文件系统完整性检查器 man:fsck[8] 可以在快照上运行。假设文件系统在被挂载时是干净的，这应该总是提供一个干净和不变的结果。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1595
msgid ""
"Running man:dump[8] on the snapshot will produce a dump file that is consistent with the file system and the timestamp of the snapshot. man:dump[8] can also take a "
"snapshot, create a dump image, and then remove the snapshot in one command by using `-L`."
msgstr "在快照上运行 man:dump[8] 会产生一个与文件系统和快照的时间戳一致的 dump 文件。man:dump[8] 也可以使用 `-L` 来获取快照，创建 dump 映像，然后删除快照。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1596
msgid "The snapshot can be mounted as a frozen image of the file system. To man:mount[8] the snapshot [.filename]#/var/snapshot/snap# run:"
msgstr "快照可以作为文件系统的冻结镜像被挂载。要 man:mount[8] 快照 [.filename]#/var/snapshot/snap#，请运行:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1601
#, no-wrap
msgid ""
"# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4\n"
"# mount -r /dev/md4 /mnt\n"
msgstr ""
"# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4\n"
"# mount -r /dev/md4 /mnt\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1607
msgid ""
"The frozen [.filename]#/var# is now available through [.filename]#/mnt#.  Everything will initially be in the same state it was during the snapshot creation time.  The "
"only exception is that any earlier snapshots will appear as zero length files.  To unmount the snapshot, use:"
msgstr ""
"被冻结的 [.filename]#/var# 现在可以通过 [.filename]#/mnt# 使用。所有文件最初都将处于快照创建时的状态。唯一的例外是，任何早期的快照将显示为零长度的文件。要解除对快照的挂"
"载，请使用:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1612
#, no-wrap
msgid ""
"# umount /mnt\n"
"# mdconfig -d -u 4\n"
msgstr ""
"# umount /mnt\n"
"# mdconfig -d -u 4\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1615
msgid ""
"For more information about `softupdates` and file system snapshots, including technical papers, visit Marshall Kirk McKusick's website at http://www.mckusick.com/[http://"
"www.mckusick.com/]."
msgstr "有关 `softupdates` 和文件系统快照的更多信息，包括技术报告，请访问 Marshall Kirk McKusick 的网站：http://www.mckusick.com/[http://www.mckusick.com/]。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1617
#, no-wrap
msgid "Disk Quotas"
msgstr "磁盘配额"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1621
msgid ""
"Disk quotas can be used to limit the amount of disk space or the number of files a user or members of a group may allocate on a per-file system basis.  This prevents one "
"user or group of users from consuming all of the available disk space."
msgstr "磁盘配额可以用来限制一个用户或一个组的成员在每个文件系统上可以分配的磁盘空间或文件数量。这可以防止一个用户或一组用户消耗所有的可用磁盘空间。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1624
msgid ""
"This section describes how to configure disk quotas for the UFS file system.  To configure quotas on the ZFS file system, refer to crossref:zfs[zfs-zfs-quota,\"Dataset, "
"User, and Group Quotas\"]"
msgstr "本节描述了如何为 UFS 文件系统配置磁盘配额。要在 ZFS 文件系统上配置配额，请参阅 crossref:zfs[zfs-zfs-quota,数据集、用户和组配额]"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1625
#, no-wrap
msgid "Enabling Disk Quotas"
msgstr "启用磁盘配额"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1628
msgid "To determine if the FreeBSD kernel provides support for disk quotas:"
msgstr "要确定 FreeBSD 内核是否提供对磁盘配额的支持，使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1633
#, no-wrap
msgid ""
"% sysctl kern.features.ufs_quota\n"
"kern.features.ufs_quota: 1\n"
msgstr ""
"% sysctl kern.features.ufs_quota\n"
"kern.features.ufs_quota: 1\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1637
msgid ""
"In this example, the `1` indicates quota support.  If the value is instead `0`, add the following line to a custom kernel configuration file and rebuild the kernel using "
"the instructions in crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"在这个例子中，`1` 表示支持配额。如果这个值是 `0` ，请在自定义的内核配置文件中加入以下一行，并按照 crossref:kernelconfig[kernelconfig,配置 FreeBSD 内核] 的说明重建内核:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1641
#, no-wrap
msgid "options QUOTA\n"
msgstr "options QUOTA\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1644
msgid "Next, enable disk quotas in [.filename]#/etc/rc.conf#:"
msgstr "接下来，在 [.filename]#/etc/rc.conf# 中启用磁盘配额："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1648
#, no-wrap
msgid "quota_enable=\"YES\"\n"
msgstr "quota_enable=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1654
msgid ""
"Normally on bootup, the quota integrity of each file system is checked by man:quotacheck[8].  This program insures that the data in the quota database properly reflects "
"the data on the file system.  This is a time consuming process that will significantly affect the time the system takes to boot.  To skip this step, add this variable to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"通常在启动时，每个文件系统的配额完整性由 man:quotacheck[8] 检查。这个程序确保配额数据库中的数据正确反映了文件系统上的数据。这是一个耗时的过程，会大大影响系统的启动时间。"
"要跳过这个步骤，请在 [.filename]#/etc/rc.conf# 中添加这个变量:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1658
#, no-wrap
msgid "check_quotas=\"NO\"\n"
msgstr "check_quotas=\"NO\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1663
msgid ""
"Finally, edit [.filename]#/etc/fstab# to enable disk quotas on a per-file system basis.  To enable per-user quotas on a file system, add `userquota` to the options field "
"in the [.filename]#/etc/fstab# entry for the file system to enable quotas on.  For example:"
msgstr ""
"最后，编辑 [.filename]#/etc/fstab# 以在每个文件系统上启用磁盘配额。要在一个文件系统上启用每个用户的配额，在文件系统的 [.filename]#/etc/fstab# 条目中的选项字段中添加 "
"`userquota` ，以启用配额。例如:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1667
#, no-wrap
msgid "/dev/da1s2g   /home    ufs rw,userquota 1 2\n"
msgstr "/dev/da1s2g   /home    ufs rw,userquota 1 2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1671
msgid "To enable group quotas, use `groupquota` instead.  To enable both user and group quotas, separate the options with a comma:"
msgstr "要启用组配额，请使用 `groupquota` 代替。要同时启用用户和组配额，请用逗号隔开选项："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1675
#, no-wrap
msgid "/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2\n"
msgstr "/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1680
msgid ""
"By default, quota files are stored in the root directory of the file system as [.filename]#quota.user# and [.filename]#quota.group#.  Refer to man:fstab[5] for more "
"information.  Specifying an alternate location for the quota files is not recommended."
msgstr ""
"默认情况下，配额文件以 [.filename]#quota.user# 和 [.filename]#quota.group# 的形式存储在文件系统的根目录下。请参考 man:fstab[5] 以了解更多信息。不建议为配额文件指定其他的"
"位置。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1682
msgid ""
"Once the configuration is complete, reboot the system and [.filename]#/etc/rc# will automatically run the appropriate commands to create the initial quota files for all "
"of the quotas enabled in [.filename]#/etc/fstab#."
msgstr "配置完成后，重新启动系统，[.filename]#/etc/rc# 将自动运行适当的命令，为 [.filename]#/etc/fstab# 中启用的所有配额创建初始配额文件。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1685
msgid ""
"In the normal course of operations, there should be no need to manually run man:quotacheck[8], man:quotaon[8], or man:quotaoff[8].  However, one should read these manual "
"pages to be familiar with their operation."
msgstr "在正常操作过程中，应该不需要手动运行 man:quotacheck[8]、 man:quotaon[8] 或 man:quotaoff[8]。然而，应该阅读这些手册页面以熟悉它们的操作"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1686
#, no-wrap
msgid "Setting Quota Limits"
msgstr "设置配额限制"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1689
msgid "To verify that quotas are enabled, run:"
msgstr "要验证配额是否已启用，请运行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1693
#, no-wrap
msgid "# quota -v\n"
msgstr "# quota -v\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1696
msgid "There should be a one line summary of disk usage and current quota limits for each file system that quotas are enabled on."
msgstr "应该有一行关于磁盘使用情况和每个文件系统的当前配额限制的摘要，这些文件系统已启用配额。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1698
msgid "The system is now ready to be assigned quota limits with `edquota`."
msgstr "现在，系统已经准备好用 `edquota` 分配配额限制。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1702
msgid ""
"Several options are available to enforce limits on the amount of disk space a user or group may allocate, and how many files they may create.  Allocations can be limited "
"based on disk space (block quotas), number of files (inode quotas), or a combination of both.  Each limit is further broken down into two categories: hard and soft "
"limits."
msgstr ""
"有几个选项可用于强制限制用户或组可以分配的磁盘空间，以及他们可以创建多少文件。可以根据磁盘空间（块配额）、文件数量（节点配额）或两者的组合来限制分配。每个限制进一步细分为"
"两类：硬限制和软限制。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1707
msgid ""
"A hard limit may not be exceeded.  Once a user reaches a hard limit, no further allocations can be made on that file system by that user.  For example, if the user has a "
"hard limit of 500 kbytes on a file system and is currently using 490 kbytes, the user can only allocate an additional 10 kbytes.  Attempting to allocate an additional 11 "
"kbytes will fail."
msgstr ""
"硬限制是不能超过的。如果有一个用户达到了硬限制，该用户就不能再在该文件系统上进行分配。例如，如果用户在一个文件系统上的硬限制是 500 kbytes，目前正在使用 490 kbytes，用户只"
"能再分配 10 kbytes。试图分配额外的 11kbytes 将会失败。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1711
msgid ""
"Soft limits can be exceeded for a limited amount of time, known as the grace period, which is one week by default.  If a user stays over their limit longer than the "
"grace period, the soft limit turns into a hard limit and no further allocations are allowed.  When the user drops back below the soft limit, the grace period is reset."
msgstr ""
"软限制可以在有限的时间内被超过，称为宽限期，默认情况下是一个星期。如果一个用户超过他们的限制超过宽限期，软限制变成了硬限制，不允许进一步分配。当用户回落到软限制以下时，宽"
"限期被重置。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1715
msgid ""
"In the following example, the quota for the `test` account is being edited.  When `edquota` is invoked, the editor specified by `EDITOR` is opened in order to edit the "
"quota limits.  The default editor is set to vi."
msgstr "在下面的例子中，测试账户的配额正在被编辑。当 `edquota` 被调用时，由 `EDITOR` 指定的编辑器被打开，以便编辑配额限制。默认编辑器被设置为 vi."

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1724
#, no-wrap
msgid ""
"# edquota -u test\n"
"Quotas for user test:\n"
"/usr: kbytes in use: 65, limits (soft = 50, hard = 75)\n"
"        inodes in use: 7, limits (soft = 50, hard = 60)\n"
"/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)\n"
"        inodes in use: 0, limits (soft = 50, hard = 60)\n"
msgstr ""
"# edquota -u test\n"
"Quotas for user test:\n"
"/usr: kbytes in use: 65, limits (soft = 50, hard = 75)\n"
"        inodes in use: 7, limits (soft = 50, hard = 60)\n"
"/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)\n"
"        inodes in use: 0, limits (soft = 50, hard = 60)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1730
msgid ""
"There are normally two lines for each file system that has quotas enabled.  One line represents the block limits and the other represents the inode limits.  Change the "
"value to modify the quota limit.  For example, to raise the block limit on [.filename]#/usr# to a soft limit of `500` and a hard limit of `600`, change the values in "
"that line as follows:"
msgstr ""
"每个启用了配额的文件系统通常有两行。一行代表块的限制，另一行代表 inode 的限制。改变数值来修改配额限制。例如，要把 [.filename]#/usr# 的块限制提高到 `500` 的软限制和 `600` "
"的硬限制，改变该行的值如下:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1734
#, no-wrap
msgid "/usr: kbytes in use: 65, limits (soft = 500, hard = 600)\n"
msgstr "/usr: kbytes in use: 65, limits (soft = 500, hard = 600)\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1737
msgid "The new quota limits take effect upon exiting the editor."
msgstr "新的配额限制在退出编辑器时生效。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1742
msgid ""
"Sometimes it is desirable to set quota limits on a range of users.  This can be done by first assigning the desired quota limit to a user.  Then, use `-p` to duplicate "
"that quota to a specified range of user IDs (UIDs).  The following command will duplicate those quota limits for UIDs `10,000` through `19,999`:"
msgstr ""
"有时，我们希望对一定范围内的用户设置配额限制。这可以通过首先为一个用户分配所需的配额限制来实现。然后，使用 `-p` 将该配额复制到指定范围的用户 ID（UID）。下面的命令将为 "
"UID `10,000` 到 `19,999` 复制这些配额限制:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1746
#, no-wrap
msgid "# edquota -p test 10000-19999\n"
msgstr "# edquota -p test 10000-19999\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1749
msgid "For more information, refer to man:edquota[8]."
msgstr "更多信息，请参考 man:edquota[8]。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1750
#, no-wrap
msgid "Checking Quota Limits and Disk Usage"
msgstr "检查配额限制和磁盘使用情况"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1756
msgid ""
"To check individual user or group quotas and disk usage, use man:quota[1].  A user may only examine their own quota and the quota of a group they are a member of.  Only "
"the superuser may view all user and group quotas.  To get a summary of all quotas and disk usage for file systems with quotas enabled, use man:repquota[8]."
msgstr ""
"要检查单个用户或组的配额和磁盘使用情况，请使用 man:quota[1] 。一个用户只能检查他自己的配额和他所属的组的配额。只有超级用户可以查看所有用户和组的配额。要获得启用了配额的文"
"件系统的所有配额和磁盘使用情况的摘要，请使用 man:repquota[8]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1760
msgid ""
"Normally, file systems that the user is not using any disk space on will not show in the output of `quota`, even if the user has a quota limit assigned for that file "
"system.  Use `-v` to display those file systems.  The following is sample output from `quota -v` for a user that has quota limits on two file systems."
msgstr ""
"通常，用户没有使用任何磁盘空间的文件系统不会显示在 `quota` 的输出中，即使用户为该文件系统分配了配额限制。使用 `-v` 来显示这些文件系统。下面是 `quota -v` 的输出示例，该用"
"户在两个文件系统上有配额限制:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1767
#, no-wrap
msgid ""
"Disk quotas for user test (uid 1002):\n"
"     Filesystem  usage    quota   limit   grace   files   quota   limit   grace\n"
"           /usr      65*     50      75   5days       7      50      60\n"
"       /usr/var       0      50      75               0      50      60\n"
msgstr ""
"Disk quotas for user test (uid 1002):\n"
"     Filesystem  usage    quota   limit   grace   files   quota   limit   grace\n"
"           /usr      65*     50      75   5days       7      50      60\n"
"       /usr/var       0      50      75               0      50      60\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1771
msgid ""
"In this example, the user is currently 15 kbytes over the soft limit of 50 kbytes on [.filename]#/usr# and has 5 days of grace period left.  The asterisk `*` indicates "
"that the user is currently over the quota limit."
msgstr "在这个例子中，用户目前在 [.filename]#/usr#  上的软限制为 50kbytes ，超过了 15kbytes ，并且还有 5 天的宽限期。星号 `*` 表示该用户目前超过了配额限制"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1772
#, no-wrap
msgid "Quotas over NFS"
msgstr "NFS上的配额"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1776
msgid ""
"Quotas are enforced by the quota subsystem on the NFS server.  The man:rpc.rquotad[8] daemon makes quota information available to `quota` on NFS clients, allowing users "
"on those machines to see their quota statistics."
msgstr "配额是由 NFS 服务器上的配额子系统执行的。man:rpc.rquotad[8] 守护进程上的配额信息对 NFS 客户端可用，允许这些机器上的用户查看他们的配额统计信息。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1778
msgid "On the NFS server, enable `rpc.rquotad` by removing the `#` from this line in [.filename]*/etc/inetd.conf*:"
msgstr "在 NFS 服务器上，通过删除 [.filename]*/etc/inetd.conf* 中这一行的 `#` 来启用 `rpc.rquotad`:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1782
#, no-wrap
msgid "rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad\n"
msgstr "rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1785
msgid "Then, restart `inetd`:"
msgstr "然后，重新启动 `inetd`："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1789
#, no-wrap
msgid "# service inetd restart\n"
msgstr "# service inetd restart\n"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:1792
#, no-wrap
msgid "Encrypting Disk Partitions"
msgstr "加密磁盘分区"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1797
msgid ""
"FreeBSD offers excellent online protections against unauthorized data access.  File permissions and crossref:mac[mac,Mandatory Access Control] (MAC) help prevent "
"unauthorized users from accessing data while the operating system is active and the computer is powered up.  However, the permissions enforced by the operating system "
"are irrelevant if an attacker has physical access to a computer and can move the computer's hard drive to another system to copy and analyze the data."
msgstr ""
"FreeBSD 提供了出色的在线保护，以防止未经授权的数据访问。文件权限和强制访问控制(MAC)有助于防止未经授权的用户在操作系统激活和计算机开机时访问数据。然而，如果攻击者拥有对计"
"算机的物理访问权，并且可以将计算机的硬盘移动到另一个系统中去复制和分析数据，那么操作系统所强制执行的权限就没有意义了。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1801
msgid ""
"Regardless of how an attacker may have come into possession of a hard drive or powered-down computer, the GEOM-based cryptographic subsystems built into FreeBSD are able "
"to protect the data on the computer's file systems against even highly-motivated attackers with significant resources.  Unlike encryption methods that encrypt individual "
"files, the built-in `gbde` and `geli` utilities can be used to transparently encrypt entire file systems.  No cleartext ever touches the hard drive's platter."
msgstr ""
"无论攻击者是如何占有硬盘或断电的计算机，FreeBSD 内置的基于 GEOM 的加密子系统都能够保护计算机文件系统中的数据，即使是拥有大量资源的高度活跃的攻击者。与加密单个文件的方法不"
"同，内置的 `gbde` 和 `geli` 工具可以被用来透明地加密整个文件系统。任何明文都不会接触到硬盘的盘面。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1804
msgid ""
"This chapter demonstrates how to create an encrypted file system on FreeBSD.  It first demonstrates the process using `gbde` and then demonstrates the same example using "
"`geli`."
msgstr "本章演示了如何在 FreeBSD 上创建一个加密的文件系统。它首先演示了使用 `gbde` 的过程，然后用 `geli` 演示了同一个例子。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1805
#, no-wrap
msgid "Disk Encryption with gbde"
msgstr "用 gbde 进行磁盘加密"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1810
msgid ""
"The objective of the man:gbde[4] facility is to provide a formidable challenge for an attacker to gain access to the contents of a _cold_ storage device.  However, if "
"the computer is compromised while up and running and the storage device is actively attached, or the attacker has access to a valid passphrase, it offers no protection "
"to the contents of the storage device.  Thus, it is important to provide physical security while the system is running and to protect the passphrase used by the "
"encryption mechanism."
msgstr ""
"man:gbde[4] 为攻击者获取冷存储设备的内容提供一个巨大的挑战。然而，如果计算机在运行时被破坏，并且存储设备被主动连接，或者攻击者能够获得有效的口令，那么它就不能为存储设备的"
"内容提供保护。因此，在系统运行时提供物理安全并保护加密机制所使用的口令是很重要的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1815
msgid ""
"This facility provides several barriers to protect the data stored in each disk sector.  It encrypts the contents of a disk sector using 128-bit AES in CBC mode.  Each "
"sector on the disk is encrypted with a different AES key.  For more information on the cryptographic design, including how the sector keys are derived from the user-"
"supplied passphrase, refer to man:gbde[4]."
msgstr ""
"该设施提供了几个屏障来保护存储在每个磁盘扇区的数据。它使用 CBC 模式下的 128 位 AES 对磁盘扇区的内容进行加密。磁盘上的每个扇区都用不同的 AES 密钥进行加密。关于加密设计的更"
"多信息，包括扇区密钥如何从用户提供的口令中获得，请参考 man:gbde[4] 。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1817
msgid "FreeBSD provides a kernel module for gbde which can be loaded with this command:"
msgstr "FreeBSD 为 gbde 提供了一个内核模块，可以用这个命令加载："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1821
#, no-wrap
msgid "# kldload geom_bde\n"
msgstr "# kldload geom_bde\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1824
msgid "If using a custom kernel configuration file, ensure it contains this line:"
msgstr "如果使用自定义的内核配置文件，确保它包含这一行："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1826
msgid "`options GEOM_BDE`"
msgstr "`options GEOM_BDE`"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1828
msgid "The following example demonstrates adding a new hard drive to a system that will hold a single encrypted partition that will be mounted as [.filename]#/private#."
msgstr "下面的例子演示了在系统中添加一个新的硬盘，该硬盘将存放一个加密的分区，该分区将被挂载为 [.filename]#/private#："

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1830
#, no-wrap
msgid "Procedure: Encrypting a Partition with gbde"
msgstr "用 gbde 加密一个分区"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1832
msgid "Add the New Hard Drive"
msgstr "添加新的硬盘驱动器"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1835
msgid ""
"Install the new drive to the system as explained in <<disks-adding>>.  For the purposes of this example, a new hard drive partition has been added as [.filename]#/dev/"
"ad4s1c# and [.filename]#/dev/ad0s1*# represents the existing standard FreeBSD partitions."
msgstr "按照“添加硬盘”中的解释，将新硬盘安装到系统中。在这个例子中，一个新的硬盘分区被添加为 [.filename]#/dev/ad4s1c#，[.filename]#/dev/ad0s1*# 代表现有的标准 FreeBSD 分区"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1842
#, no-wrap
msgid ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4\n"
msgstr ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1845
msgid "Create a Directory to Hold `gbde` Lock Files"
msgstr "创建一个存放 `gbde` 锁定文件的目录"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1849
#, no-wrap
msgid "# mkdir /etc/gbde\n"
msgstr "# mkdir /etc/gbde\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1854
msgid ""
"The gbde lock file contains information that gbde requires to access encrypted partitions.  Without access to the lock file, gbde will not be able to decrypt the data "
"contained in the encrypted partition without significant manual intervention which is not supported by the software.  Each encrypted partition uses a separate lock file."
msgstr ""
"gbde 锁文件包含 gbde 访问加密分区所需的信息。如果不能访问锁文件，在没有大量人工干预的情况下，gbde 将不能解密加密分区中包含的数据，而软件不支持人工干预。每个加密分区都使用一"
"个单独的锁文件"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1855
msgid "Initialize the `gbde` Partition"
msgstr "初始化 `gbde` 分区"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1860
msgid ""
"A gbde partition must be initialized before it can be used.  This initialization needs to be performed only once.  This command will open the default editor, in order to "
"set various configuration options in a template.  For use with the UFS file system, set the sector_size to 2048:"
msgstr ""
"一个gbde分区在被使用之前必须被初始化。该初始化只需要执行一次。该命令将打开默认编辑器，以便在一个模板中设置各种配置选项。为了与 UFS 文件系统一起使用，将扇区大小设置为 "
"2048。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1873
#, no-wrap
msgid ""
"# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
"# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $\n"
"#\n"
"# Sector size is the smallest unit of data which can be read or written.\n"
"# Making it too small decreases performance and decreases available space.\n"
"# Making it too large may prevent filesystems from working.  512 is the\n"
"# minimum and always safe.  For UFS, use the fragment size\n"
"#\n"
"sector_size\t=\t2048\n"
"[...]\n"
msgstr ""
"# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
"# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $\n"
"#\n"
"# Sector size is the smallest unit of data which can be read or written.\n"
"# Making it too small decreases performance and decreases available space.\n"
"# Making it too large may prevent filesystems from working.  512 is the\n"
"# minimum and always safe.  For UFS, use the fragment size\n"
"#\n"
"sector_size\t=\t2048\n"
"[...]\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1879
msgid ""
"Once the edit is saved, the user will be asked twice to type the passphrase used to secure the data.  The passphrase must be the same both times.  The ability of gbde to "
"protect data depends entirely on the quality of the passphrase.  For tips on how to select a secure passphrase that is easy to remember, see http://world.std.com/"
"\\~reinhold/diceware.html[http://world.std.com/~reinhold/diceware.htm]."
msgstr ""
"编辑被保存之后，用户将被要求两次输入用于保护数据的口令。这两次的口令必须是相同的。gbde 保护数据的能力完全取决于口令的质量。关于如何选择一个容易记住的安全口令的提示，见 "
"http://world.std.com/\\~reinhold/diceware.html[http://world.std.com/~reinhold/diceware.htm]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1883
msgid ""
"This initialization creates a lock file for the gbde partition.  In this example, it is stored as [.filename]#/etc/gbde/ad4s1c.lock#.  Lock files must end in \".lock\" "
"in order to be correctly detected by the [.filename]#/etc/rc.d/gbde# start up script."
msgstr ""
"该初始化为 gbde 分区创建一个锁文件。在这个例子中，它被存储为 [.filename]#/etc/gbde/ad4s1c.lock# 。锁定文件必须以 \".lock\" 结尾，以便被 [.filename]#/etc/rc.d/gbde# 启动脚"
"本正确检测。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1888
msgid ""
"Lock files _must_ be backed up together with the contents of any encrypted partitions.  Without the lock file, the legitimate owner will be unable to access the data on "
"the encrypted partition."
msgstr "锁定文件必须与任何加密分区的内容一起进行备份。如果没有锁定文件，合法所有者也将无法访问加密分区上的数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1891
msgid "Attach the Encrypted Partition to the Kernel"
msgstr "将加密的分区附加到内核上"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1895
#, no-wrap
msgid "# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock\n"
msgstr "# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1899
msgid ""
"This command will prompt to input the passphrase that was selected during the initialization of the encrypted partition.  The new encrypted device will appear in [."
"filename]#/dev# as [.filename]#/dev/device_name.bde#:"
msgstr "该命令将提示输入初始化加密分区时选择的口令。新的加密设备将作为 [.filename]#/dev/device_name.bde# 出现在 [.filename]#/dev# 中："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1906
#, no-wrap
msgid ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde\n"
msgstr ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1909
msgid "Create a File System on the Encrypted Device"
msgstr "在加密的设备上创建一个文件系统"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1913
msgid ""
"Once the encrypted device has been attached to the kernel, a file system can be created on the device.  This example creates a UFS file system with soft updates "
"enabled.  Be sure to specify the partition which has a [.filename]#*.bde# extension:"
msgstr "加密的设备被连接到内核后，就可以在设备上创建一个文件系统。这个例子创建了一个 UFS 文件系统，启用了软更新。请确保指定具有 [.filename]#*.bde# 扩展名的分区:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1917
#, no-wrap
msgid "# newfs -U /dev/ad4s1c.bde\n"
msgstr "# newfs -U /dev/ad4s1c.bde\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1920
msgid "Mount the Encrypted Partition"
msgstr "挂载加密的分区"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1922
msgid "Create a mount point and mount the encrypted file system:"
msgstr "创建一个挂载点并挂载加密的文件系统："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1927
#, no-wrap
msgid ""
"# mkdir /private\n"
"# mount /dev/ad4s1c.bde /private\n"
msgstr ""
"# mkdir /private\n"
"# mount /dev/ad4s1c.bde /private\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1930
msgid "Verify That the Encrypted File System is Available"
msgstr "验证加密的文件系统是否可用"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1932
msgid "The encrypted file system should now be visible and available for use:"
msgstr "加密的文件系统现在应该是可见的并且可供使用："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1943
#, no-wrap
msgid ""
"% df -H\n"
"Filesystem        Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a      1037M    72M   883M     8%    /\n"
"/devfs            1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f       8.1G    55K   7.5G     0%    /home\n"
"/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp\n"
"/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr\n"
"/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private\n"
msgstr ""
"% df -H\n"
"Filesystem        Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a      1037M    72M   883M     8%    /\n"
"/devfs            1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f       8.1G    55K   7.5G     0%    /home\n"
"/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp\n"
"/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr\n"
"/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1947
msgid ""
"After each boot, any encrypted file systems must be manually re-attached to the kernel, checked for errors, and mounted, before the file systems can be used.  To "
"configure these steps, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr ""
"每次启动后，任何加密的文件系统都必须手动重新连接到内核，检查是否有错误，并挂载，然后才能使用这些文件系统。要配置这些步骤，请在 [.filename]#/etc/rc.conf# 中添加以下几行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1953
#, no-wrap
msgid ""
"gbde_autoattach_all=\"YES\"\n"
"gbde_devices=\"ad4s1c\"\n"
"gbde_lockdir=\"/etc/gbde\"\n"
msgstr ""
"gbde_autoattach_all=\"YES\"\n"
"gbde_devices=\"ad4s1c\"\n"
"gbde_lockdir=\"/etc/gbde\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:1958
msgid ""
"This requires that the passphrase be entered at the console at boot time.  After typing the correct passphrase, the encrypted partition will be mounted automatically.  "
"Additional gbde boot options are available and listed in man:rc.conf[5]."
msgstr "这需要在启动时在控制台输入密码。输入正确的口令后，加密的分区将被自动挂载。其他 gbde 启动选项是可用的，在 man:rc.conf[5] 中列出。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1964
msgid ""
"sysinstall is incompatible with gbde-encrypted devices.  All [.filename]#*.bde# devices must be detached from the kernel before starting sysinstall or it will crash "
"during its initial probing for devices.  To detach the encrypted device used in the example, use the following command:"
msgstr ""
"sysinstall 与 gbde-encrypted 设备不兼容。在启动 sysinstall 之前，所有 [.filename]#*.bde# 设备必须从内核中分离出来，否则它在最初探测设备时将崩溃。要分离本例中使用的加密设"
"备，使用下面的命令:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1968
#, no-wrap
msgid "# gbde detach /dev/ad4s1c\n"
msgstr "# gbde detach /dev/ad4s1c\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:1972
#, no-wrap
msgid "Disk Encryption with `geli`"
msgstr "用 `geli` 进行磁盘加密"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1977
msgid ""
"An alternative cryptographic GEOM class is available using `geli`.  This control utility adds some features and uses a different scheme for doing cryptographic work.  It "
"provides the following features:"
msgstr "使用 `geli` 可以获得另一种 GEOM 加密级别。这个控制工具增加了一些功能，并使用一个不同的方案来做加密工作。它提供了以下功能："

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1979
msgid "Utilizes the man:crypto[9] framework and automatically uses cryptographic hardware when it is available."
msgstr "利用 man:crypto[9] 框架，在有加密硬件时自动使用。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1980
msgid "Supports multiple cryptographic algorithms such as AES, Blowfish, and 3DES."
msgstr "支持多种加密算法，如 AES、Blowfish 和 3DES。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1981
msgid "Allows the root partition to be encrypted. The passphrase used to access the encrypted root partition will be requested during system boot."
msgstr "允许对根分区进行加密。在系统启动时，将要求提供用于访问加密的根分区的口令。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1982
msgid "Allows the use of two independent keys."
msgstr "允许使用两个独立的密钥。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1983
msgid "It is fast as it performs simple sector-to-sector encryption."
msgstr "它是快速的，因为它执行简单的扇区到扇区的加密。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1984
msgid "Allows backup and restore of master keys. If a user destroys their keys, it is still possible to get access to the data by restoring keys from the backup."
msgstr "允许备份和恢复主密钥。如果用户破坏了他们的密钥，仍有可能通过从备份中恢复密钥来获取数据。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1985
msgid "Allows a disk to attach with a random, one-time key which is useful for swap partitions and temporary file systems."
msgstr "允许磁盘附加一个随机的、一次性的密钥，这对交换分区和临时文件系统很有用。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1987
msgid "More features and usage examples can be found in man:geli[8]."
msgstr "更多的功能和使用实例可以在 man:geli[8] 中找到。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1993
msgid ""
"The following example describes how to generate a key file which will be used as part of the master key for the encrypted provider mounted under [.filename]#/private#.  "
"The key file will provide some random data used to encrypt the master key.  The master key will also be protected by a passphrase.  The provider's sector size will be "
"4kB.  The example describes how to attach to the `geli` provider, create a file system on it, mount it, work with it, and finally, how to detach it."
msgstr ""
"下面的例子描述了如何生成一个密钥文件，该文件将被用作安装在 [.filename]#/private# 下的加密提供者的主密钥的一部分。密钥文件将提供一些用于加密主密钥的随机数据。主密钥也将受"
"到口令的保护。提供者的扇区大小将是 4kB 。这个例子描述了如何附加到 `geli` 提供器上，在它上面创建一个文件系统，挂载它，使用它，最后是如何分离它"

#. type: Block title
#: content/zh-cn/books/handbook/disks/_index.adoc:1995
#, no-wrap
msgid "Procedure: Encrypting a Partition with `geli`"
msgstr "程序：用 `geli` 加密一个分区"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1997
msgid "Load `geli` Support"
msgstr "加载 `geli` 的支持"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:1999
msgid ""
"Support for `geli` is available as a loadable kernel module. To configure the system to automatically load the module at boot time, add the following line to [."
"filename]#/boot/loader.conf#:"
msgstr "支持对 geli 的支持是作为一个可加载的内核模块提供的。要配置系统在启动时自动加载该模块，请在 [.filename]#/boot/loader.conf# 中添加以下一行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2003
#, no-wrap
msgid "geom_eli_load=\"YES\"\n"
msgstr "geom_eli_load=\"YES\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2006
msgid "To load the kernel module now:"
msgstr "立即加载这个内核模块："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2010
#, no-wrap
msgid "# kldload geom_eli\n"
msgstr "# kldload geom_eli\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2013
msgid "For a custom kernel, ensure the kernel configuration file contains these lines:"
msgstr "对于一个自定义的内核，确保内核配置文件包含这些行："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2018
#, no-wrap
msgid ""
"options GEOM_ELI\n"
"device crypto\n"
msgstr ""
"options GEOM_ELI\n"
"device crypto\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2021
msgid "Generate the Master Key"
msgstr "生成主密钥"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2028
msgid ""
"The following commands generate a master key that all data will be encrypted with.  This key can never be changed.  Rather than using it directly, it is encrypted with "
"one or more user keys.  The user keys are made up of an optional combination of random bytes from a file, [.filename]#/root/da2.key#, and/or a passphrase.  In this case, "
"the data source for the key file is [.filename]#/dev/random#.  This command also configures the sector size of the provider ([.filename]#/dev/da2.eli#) as 4kB, for "
"better performance:"
msgstr ""
"下面的命令生成了一个主密钥，所有的数据都将用这个密钥进行加密。这个密钥永远不能被改变。与其直接使用它，不如用一个或多个用户密钥进行加密。用户密钥是由文件 "
"[.filename]#/root/da2.key# 中的随机字节和/或口令的可选组合组成的。在这种情况下，密钥文件的数据源是 [.filename]#/dev/random# 。该命令还将提供者（[.filename]#/dev/da2.eli#）的扇区大小配"
"置为 4kB，以获得更好的性能"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2035
#, no-wrap
msgid ""
"# dd if=/dev/random of=/root/da2.key bs=64 count=1\n"
"# geli init -K /root/da2.key -s 4096 /dev/da2\n"
"Enter new passphrase:\n"
"Reenter new passphrase:\n"
msgstr ""
"# dd if=/dev/random of=/root/da2.key bs=64 count=1\n"
"# geli init -K /root/da2.key -s 4096 /dev/da2\n"
"Enter new passphrase:\n"
"Reenter new passphrase:\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2038
msgid "It is not mandatory to use both a passphrase and a key file as either method of securing the master key can be used in isolation."
msgstr "并非一定要同时使用口令和密钥文件，因为任何一种保护主密钥的方法都可以单独使用。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2041
msgid "If the key file is given as \"-\", standard input will be used.  For example, this command generates three key files:"
msgstr "如果钥匙文件以 \"-\", 的形式给出，将使用标准输入。例如，这个命令产生了三个密钥文件。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2045
#, no-wrap
msgid "# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2\n"
msgstr "# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2048
msgid "Attach the Provider with the Generated Key"
msgstr "用生成的密钥连接加密分区"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2050
msgid "To attach the provider, specify the key file, the name of the disk, and the passphrase:"
msgstr "要连接加密分区，指定密钥文件、磁盘名称和口令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2055
#, no-wrap
msgid ""
"# geli attach -k /root/da2.key /dev/da2\n"
"Enter passphrase:\n"
msgstr ""
"# geli attach -k /root/da2.key /dev/da2\n"
"Enter passphrase:\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2058
msgid "This creates a new device with an [.filename]#.eli# extension:"
msgstr "这将创建一个带有 [.filename]#.eli# 扩展名的新设备:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2063
#, no-wrap
msgid ""
"# ls /dev/da2*\n"
"/dev/da2  /dev/da2.eli\n"
msgstr ""
"# ls /dev/da2*\n"
"/dev/da2  /dev/da2.eli\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2066
msgid "Create the New File System"
msgstr "创建新的文件系统"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2068
msgid "Next, format the device with the UFS file system and mount it on an existing mount point:"
msgstr "接下来，用 UFS 文件系统格式化该设备，并将其挂载到一个现有的挂载点。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2074
#, no-wrap
msgid ""
"# dd if=/dev/random of=/dev/da2.eli bs=1m\n"
"# newfs /dev/da2.eli\n"
"# mount /dev/da2.eli /private\n"
msgstr ""
"# dd if=/dev/random of=/dev/da2.eli bs=1m\n"
"# newfs /dev/da2.eli\n"
"# mount /dev/da2.eli /private\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2077
msgid "The encrypted file system should now be available for use:"
msgstr "加密的文件系统现在应该可以使用了"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2088
#, no-wrap
msgid ""
"# df -H\n"
"Filesystem     Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a    248M    89M   139M    38%    /\n"
"/devfs         1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr\n"
"/dev/ad0s1d    989M   1.5M   909M     0%    /tmp\n"
"/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var\n"
"/dev/da2.eli   150G   4.1K   138G     0%    /private\n"
msgstr ""
"# df -H\n"
"Filesystem     Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a    248M    89M   139M    38%    /\n"
"/devfs         1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr\n"
"/dev/ad0s1d    989M   1.5M   909M     0%    /tmp\n"
"/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var\n"
"/dev/da2.eli   150G   4.1K   138G     0%    /private\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2091
msgid ""
"Once the work on the encrypted partition is done, and the [.filename]#/private# partition is no longer needed, it is prudent to put the device into cold storage by "
"unmounting and detaching the `geli` encrypted partition from the kernel:"
msgstr "加密分区的工作完成后，如果不再需要 [.filename]#/private# 分区，谨慎的做法是让设备进入冷存储，将 `geli` 加密分区从内核中卸载并分离出来。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2096
#, no-wrap
msgid ""
"# umount /private\n"
"# geli detach da2.eli\n"
msgstr ""
"# umount /private\n"
"# geli detach da2.eli\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2099
msgid ""
"An [.filename]#rc.d# script is provided to simplify the mounting of `geli`-encrypted devices at boot time. For this example, add these lines to [.filename]#/etc/rc.conf#:"
msgstr "我们提供了一个 [.filename]#rc.d# 脚本来简化启动时挂载 `geli` 加密设备的过程。对于这个例子，在 [.filename]#/etc/rc.conf# 中添加这些行。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2104
#, no-wrap
msgid ""
"geli_devices=\"da2\"\n"
"geli_da2_flags=\"-k /root/da2.key\"\n"
msgstr ""
"geli_devices=\"da2\"\n"
"geli_da2_flags=\"-k /root/da2.key\"\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2114
msgid ""
"This configures [.filename]#/dev/da2# as a `geli` provider with a master key of [.filename]#/root/da2.key#.  The system will automatically detach the provider from the "
"kernel before the system shuts down.  During the startup process, the script will prompt for the passphrase before attaching the provider.  Other kernel messages might "
"be shown before and after the password prompt.  If the boot process seems to stall, look carefully for the password prompt among the other messages.  Once the correct "
"passphrase is entered, the provider is attached.  The file system is then mounted, typically by an entry in [.filename]#/etc/fstab#.  Refer to crossref:basics[mount-"
"unmount,“Mounting and Unmounting File Systems”] for instructions on how to configure a file system to mount at boot time."
msgstr ""
"这就把 [.filename]#/dev/da2# 配置为一个 `geli` 分区，主密钥为 [.filename]#/root/da2.key# 。在系统关闭之前，系统将自动从内核中分离出分区。在启动过程中，脚本会在连接分区之"
"前提示输入口令。在密码提示前后可能会出现其他内核信息。如果启动过程似乎停滞不前，仔细寻找其他信息中的密码提示。只要输入了正确的口令，分区就会被连接。然后，文件系统被挂载，"
"通常是通过 [.filename]#/etc/fstab# 中的一个条目。关于如何配置文件系统在启动时挂载，请参考 crossref:basics[mount-unmount,挂载和卸载文件系统] 的说明。"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:2116
#, no-wrap
msgid "Encrypting Swap"
msgstr "加密交换分区"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2123
msgid ""
"Like the encryption of disk partitions, encryption of swap space is used to protect sensitive information.  Consider an application that deals with passwords.  As long "
"as these passwords stay in physical memory, they are not written to disk and will be cleared after a reboot.  However, if FreeBSD starts swapping out memory pages to "
"free space, the passwords may be written to the disk unencrypted.  Encrypting swap space can be a solution for this scenario."
msgstr ""
"与磁盘分区的加密一样，交换空间的加密也是用于保护敏感信息。考虑一个处理密码的应用程序。只要这些密码停留在物理内存中，它们就不会被写入磁盘，并且在重启后会被清除掉。然而，如"
"果 FreeBSD 开始交换内存页以释放空间，密码可能会被未加密地写入磁盘。加密交换空间可以作为这种情况的解决方案。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2126
msgid ""
"This section demonstrates how to configure an encrypted swap partition using man:gbde[8] or man:geli[8] encryption.  It assumes that [.filename]#/dev/ada0s1b# is the "
"swap partition."
msgstr "本节演示了如何使用 man:gbde[8] 或 man:geli[8] 加密法配置一个加密的交换分区。它假定 [.filename]#/dev/ada0s1b# 是交换分区。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:2127
#, no-wrap
msgid "Configuring Encrypted Swap"
msgstr "配置交换分区加密"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2131
msgid ""
"Swap partitions are not encrypted by default and should be cleared of any sensitive data before continuing.  To overwrite the current swap partition with random garbage, "
"execute the following command:"
msgstr "在默认情况下是不加密交换分区的，在继续之前应该清除任何敏感数据。要用随机的垃圾覆盖当前的交换分区，请执行以下命令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2135
#, no-wrap
msgid "# dd if=/dev/random of=/dev/ada0s1b bs=1m\n"
msgstr "# dd if=/dev/random of=/dev/ada0s1b bs=1m\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2138
msgid "To encrypt the swap partition using man:gbde[8], add the `.bde` suffix to the swap line in [.filename]#/etc/fstab#:"
msgstr "要使用 man:gbde[8] 对交换分区进行加密，在 [.filename]#/etc/fstab# 中的交换行添加 `.bde` 后缀："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2143
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.bde\tnone\t\tswap\tsw\t\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.bde\tnone\t\tswap\tsw\t\t0\t0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2146
msgid "To instead encrypt the swap partition using man:geli[8], use the `.eli` suffix:"
msgstr "要使用 man:geli[8] 加密交换分区，请使用 `.eli` 后缀:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2151
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw\t\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw\t\t0\t0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2156
msgid ""
"By default, man:geli[8] uses the AES algorithm with a key length of 128 bits.  Normally the default settings will suffice.  If desired, these defaults can be altered in "
"the options field in [.filename]#/etc/fstab#. The possible flags are:"
msgstr ""
"默认情况下，man:geli[8] 使用 AES 算法，密钥长度为 128 位。通常情况下，默认设置就足够了。如果需要，这些默认值可以在 [.filename]#/etc/fstab# 的 options 字段中进行修改。可能"
"的标志是："

#. type: Labeled list
#: content/zh-cn/books/handbook/disks/_index.adoc:2157
#, no-wrap
msgid "aalgo"
msgstr "aalgo"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2160
msgid "Data integrity verification algorithm used to ensure that the encrypted data has not been tampered with.  See man:geli[8] for a list of supported algorithms."
msgstr "数据完整性验证算法，用于确保加密的数据没有被篡改。支持的算法列表见 man:geli[8]。"

#. type: Labeled list
#: content/zh-cn/books/handbook/disks/_index.adoc:2161
#, no-wrap
msgid "ealgo"
msgstr "ealgo"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2164
msgid "Encryption algorithm used to protect the data.  See man:geli[8] for a list of supported algorithms."
msgstr "用来保护数据的加密算法。参见 man:geli[8] 获取支持的算法列表。"

#. type: Labeled list
#: content/zh-cn/books/handbook/disks/_index.adoc:2165
#, no-wrap
msgid "keylen"
msgstr "keylen"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2168
msgid "The length of the key used for the encryption algorithm.  See man:geli[8] for the key lengths that are supported by each encryption algorithm."
msgstr "用于加密算法的密钥的长度。关于每种加密算法所支持的密钥长度，见 man:geli[8]。"

#. type: Labeled list
#: content/zh-cn/books/handbook/disks/_index.adoc:2169
#, no-wrap
msgid "sectorsize"
msgstr "sectorsize"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2173
msgid ""
"The size of the blocks data is broken into before it is encrypted.  Larger sector sizes increase performance at the cost of higher storage overhead.  The recommended "
"size is 4096 bytes."
msgstr "数据在加密前被分割成的块的大小。较大的扇区大小可以提高性能，但代价是较高的存储开销。推荐的大小是 4096 字节。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2175
msgid "This example configures an encrypted swap partition using the Blowfish algorithm with a key length of 128 bits and a sectorsize of 4 kilobytes:"
msgstr "这个例子使用 Blowfish 算法配置了一个加密的交换分区，密钥长度为 128 位，扇区大小为 4 千字节。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2180
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=blowfish,keylen=128,sectorsize=4096\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=blowfish,keylen=128,sectorsize=4096\t0\t0\n"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:2182
#, no-wrap
msgid "Encrypted Swap Verification"
msgstr "加密交换空间校验"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2185
msgid "Once the system has rebooted, proper operation of the encrypted swap can be verified using `swapinfo`."
msgstr "只要系统重新启动，可以使用 `swapinfo` 验证加密交换的正确操作。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2187
msgid "If man:gbde[8] is being used:"
msgstr "如果使用 man:gbde[8] ："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2193
#, no-wrap
msgid ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.bde   542720        0   542720     0\n"
msgstr ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.bde   542720        0   542720     0\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2196
msgid "If man:geli[8] is being used:"
msgstr "如果使用 man:geli[8] ："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2202
#, no-wrap
msgid ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.eli   542720        0   542720     0\n"
msgstr ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.eli   542720        0   542720     0\n"

#. type: Title ==
#: content/zh-cn/books/handbook/disks/_index.adoc:2205
#, no-wrap
msgid "Highly Available Storage (HAST)"
msgstr "高可用性存储（HAST）"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2211
msgid ""
"High availability is one of the main requirements in serious business applications and highly-available storage is a key component in such environments.  In FreeBSD, the "
"Highly Available STorage (HAST) framework allows transparent storage of the same data across several physically separated machines connected by a TCP/IP network.  HAST "
"can be understood as a network-based RAID1 (mirror), and is similar to the DRBD(R) storage system used in the GNU/Linux(R) platform.  In combination with other high-"
"availability features of FreeBSD like CARP, HAST makes it possible to build a highly-available storage cluster that is resistant to hardware failures."
msgstr ""
"高可用性是商业应用的主要要求之一，而高可用性的存储是这种环境中的一个关键组成部分。在 FreeBSD 中，高可用性存储（HAST）框架允许在由 TCP/IP 网络连接的几台物理上分离的机器上"
"透明地存储相同的数据。HAST 可以被理解为基于网络的 RAID1（镜像），并且类似于 GNU/Linux(R) 平台中使用的 DRBD(R) 存储系统。与 FreeBSD 的其他高可用性功能（如 CARP ）相结合，"
"HAST 使得建立一个高可用性的存储集群成为可能，它可以抵抗硬件故障的发生。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2213
msgid "The following are the main features of HAST:"
msgstr "以下是 HAST 的主要特点："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2215
msgid "Can be used to mask I/O errors on local hard drives."
msgstr "可以用来掩盖本地硬盘上的 I/O 错误。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2216
msgid "File system agnostic as it works with any file system supported by FreeBSD."
msgstr "与文件系统无关，因为它可以与 FreeBSD 支持的任何文件系统一起工作。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2217
msgid "Efficient and quick resynchronization as only the blocks that were modified during the downtime of a node are synchronized."
msgstr "高效和快速的重新同步，因为只有在一个节点停机期间被修改的块才会被同步。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2218
msgid "Can be used in an already deployed environment to add additional redundancy."
msgstr "可以在已经部署的环境中使用，以增加额外的冗余度。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2219
msgid "Together with CARP, Heartbeat, or other tools, it can be used to build a robust and durable storage system."
msgstr "与 CARP 、 Heartbeat 或其他工具一起，它可以用来建立一个强大而持久的存储系统。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2221
msgid "After reading this section, you will know:"
msgstr "读完本节后，你会了解："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2223
msgid "What HAST is, how it works, and which features it provides."
msgstr "什么是 HAST，它是如何工作的，以及它提供哪些功能。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2224
msgid "How to set up and use HAST on FreeBSD."
msgstr "如何在 FreeBSD 上设置和使用 HAST。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2225
msgid "How to integrate CARP and man:devd[8] to build a robust storage system."
msgstr "如何整合 CARP 和 man:devd[8] 来建立一个强大的存储系统。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2227
msgid "Before reading this section, you should:"
msgstr "在阅读本节之前，你应该："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2229
msgid "Understand UNIX(R) and FreeBSD basics (crossref:basics[basics,FreeBSD Basics])."
msgstr "了解 UNIX(R) 和 FreeBSD 的基础知识 (crossref:basics[basics,FreeBSD 基础知识])。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2230
msgid "Know how to configure network interfaces and other core FreeBSD subsystems (crossref:config[config-tuning,Configuration and Tuning])."
msgstr "知道如何配置网络接口和其他核心的 FreeBSD 子系统（crossref:config[config-tuning,配置和调整]）。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2231
msgid "Have a good understanding of FreeBSD networking (crossref:partiv[network-communication,\"Network Communication\"])."
msgstr "对 FreeBSD 网络有一个很好的理解（crossref:partiv[network-communication,网络通信]）"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2233
msgid ""
"The HAST project was sponsored by The FreeBSD Foundation with support from http://www.omc.net/[http://www.omc.net/] and http://www.transip.nl/[http://www.transip.nl/]."
msgstr "HAST 项目由 FreeBSD 基金会赞助，并得到了 http://www.omc.net/[http://www.omc.net/] 和 http://www.transip.nl/[http://www.transip.nl/] 的支持。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:2234
#, no-wrap
msgid "HAST Operation"
msgstr "HAST 操作"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2238
msgid ""
"HAST provides synchronous block-level replication between two physical machines: the _primary_ node and the _secondary_ node.  These two machines together are referred "
"to as a cluster."
msgstr "HAST 在两台物理机之间提供同步的块级复制：_主_ 节点和 _辅助_ 节点。这两台机器一起被称为一个集群。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2242
msgid ""
"Since HAST works in a primary-secondary configuration, it allows only one of the cluster nodes to be active at any given time.  The primary node, also called _active_, "
"is the one which will handle all the I/O requests to HAST-managed devices.  The secondary node is automatically synchronized from the primary node."
msgstr ""
"由于 HAST 在主-次配置中工作，它只允许集群节点中的一个在任何特定时间处于活动状态。主节点，也叫 _活动节点_，是一个将处理所有 I/O 请求的 HAST 管理的设备。次要节点是自动从主"
"要节点同步的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2244
msgid "The physical components of the HAST system are the local disk on primary node, and the disk on the remote, secondary node."
msgstr "HAST 系统的物理组件是主节点上的本地磁盘，以及远程的次要节点上的磁盘。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2248
msgid ""
"HAST operates synchronously on a block level, making it transparent to file systems and applications.  HAST provides regular GEOM providers in [.filename]#/dev/hast/# "
"for use by other tools or applications.  There is no difference between using HAST-provided devices and raw disks or partitions."
msgstr ""
"HAST 在块级上同步运行，使它对文件系统和应用程序透明。HAST 在 [.filename]#/dev/hast/# 中提供了常规的 GEOM 提供者，供其他工具或应用程序使用。使用 HAST 提供的设备和原始磁盘"
"或分区之间没有区别。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2252
msgid ""
"Each write, delete, or flush operation is sent to both the local disk and to the remote disk over TCP/IP.  Each read operation is served from the local disk, unless the "
"local disk is not up-to-date or an I/O error occurs.  In such cases, the read operation is sent to the secondary node."
msgstr ""
"每个写入、删除或刷新操作都通过 TCP/IP 发送到本地磁盘和远程磁盘。每个读操作都是从本地磁盘提供的，除非本地磁盘不是最新的或发生 I/O 错误。在这种情况下，读取操作被发送到辅助"
"节点。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2256
msgid ""
"HAST tries to provide fast failure recovery.  For this reason, it is important to reduce synchronization time after a node's outage.  To provide fast synchronization, "
"HAST manages an on-disk bitmap of dirty extents and only synchronizes those during a regular synchronization, with an exception of the initial sync."
msgstr ""
"HAST 试图提供快速的故障恢复。出于这个原因，在一个节点的故障后减少同步时间是很重要的。为了提供快速的同步，HAST 管理一个磁盘上的 dirty extents bitmap，并且只在常规的同步过"
"程中同步这些 bitmap，但初始同步除外。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2259
msgid "There are many ways to handle synchronization.  HAST implements several replication modes to handle different synchronization methods:"
msgstr "有许多方法来处理同步问题。HAST 实现了几种复制模式来处理不同的同步方法："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2261
msgid ""
"_memsync_: This mode reports a write operation as completed when the local write operation is finished and when the remote node acknowledges data arrival, but before "
"actually storing the data. The data on the remote node will be stored directly after sending the acknowledgement. This mode is intended to reduce latency, but still "
"provides good reliability. This mode is the default."
msgstr ""
"_memsync_: 这种模式下，当本地写操作完成，远程节点确认数据到达时，但在实际存储数据之前，报告写操作完成。远程节点上的数据将在发送确认后直接存储。这种模式旨在减少延迟，但仍"
"然提供良好的可靠性。这种模式是默认的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2262
msgid ""
"_fullsync_: This mode reports a write operation as completed when both the local write and the remote write complete. This is the safest and the slowest replication mode."
msgstr "_fullsync_: 当本地写和远程写都完成时，这种模式报告写操作已经完成。这是最安全和最慢的复制模式。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2263
msgid ""
"_async_: This mode reports a write operation as completed when the local write completes. This is the fastest and the most dangerous replication mode. It should only be "
"used when replicating to a distant node where latency is too high for other modes."
msgstr "_async_: 这种模式在本地写操作完成后报告为完成。这是最快速和最危险的复制模式。它只应该在复制到远方节点时使用，因为其他模式的延迟太高。"

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:2264
#, no-wrap
msgid "HAST Configuration"
msgstr "HAST 配置"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2267
msgid "The HAST framework consists of several components:"
msgstr "HAST 框架由几个部分组成:"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2269
msgid "The man:hastd[8] daemon which provides data synchronization. When this daemon is started, it will automatically load `geom_gate.ko`."
msgstr "man:hastd[8] 守护进程，提供数据同步。当这个守护进程被启动时，它将自动加载 `geom_gate.ko`。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2270
msgid "The userland management utility, man:hastctl[8]."
msgstr "用户区管理工具，man:hastctl[8]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2271
msgid "The man:hast.conf[5] configuration file. This file must exist before starting hastd."
msgstr "man:hast.conf[5] 配置文件。这个文件在启动 hastd 之前必须存在。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2273
msgid ""
"Users who prefer to statically build `GEOM_GATE` support into the kernel should add this line to the custom kernel configuration file, then rebuild the kernel using the "
"instructions in crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"如果用户希望在内核中静态地建立 `GEOM_GATE` 支持，则应在自定义的内核配置文件中加入这一行，然后按照 crossref:kernelconfig[kernelconfig,配置 FreeBSD 内核] 的说明重建内核:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2277
#, no-wrap
msgid "options\tGEOM_GATE\n"
msgstr "options\tGEOM_GATE\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2283
msgid ""
"The following example describes how to configure two nodes in primary-secondary operation using HAST to replicate the data between the two.  The nodes will be called "
"`hasta`, with an IP address of `172.16.0.1`, and `hastb`, with an IP address of `172.16.0.2`.  Both nodes will have a dedicated hard drive [.filename]#/dev/ad6# of the "
"same size for HAST operation.  The HAST pool, sometimes referred to as a resource or the GEOM provider in [.filename]#/dev/hast/#, will be called `test`."
msgstr ""
"下面的例子描述了如何在主-次操作中配置两个节点，使用 HAST 在两者之间复制数据。这些节点将被称为 hasta ，其 IP 地址为 `172.16.0.1` ； `hastb` ，其IP地址为 `172.16.0.2` 。两"
"个节点将有一个相同大小的专用硬盘 [.filename]#/dev/ad6# 用于 HAST 操作。HAST 池，有时被称为资源或 [.filename]#/dev/hast/# 中的 GEOM 提供者，将被称为 `test`。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2287
msgid "Configuration of HAST is done using [.filename]#/etc/hast.conf#.  This file should be identical on both nodes.  The simplest configuration is:"
msgstr "HAST 的配置是使用 [.filename]#/etc/hast.conf# 完成的。这个文件在两个节点上应该是相同的。最简单的配置是："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2300
#, no-wrap
msgid ""
"resource test {\n"
"\ton hasta {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.2\n"
"\t}\n"
"\ton hastb {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.1\n"
"\t}\n"
"}\n"
msgstr ""
"resource test {\n"
"\ton hasta {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.2\n"
"\t}\n"
"\ton hastb {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.1\n"
"\t}\n"
"}\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2303
msgid "For more advanced configuration, refer to man:hast.conf[5]."
msgstr "更多高级配置请参考 man:hast.conf[5]"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2307
msgid "It is also possible to use host names in the `remote` statements if the hosts are resolvable and defined either in [.filename]#/etc/hosts# or in the local DNS."
msgstr "如果在 [.filename]#/etc/hosts# 或本地 DNS 中定义的主机是可解析的，也可以在 `remote` 语句中使用主机名。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2311
msgid ""
"Once the configuration exists on both nodes, the HAST pool can be created.  Run these commands on both nodes to place the initial metadata onto the local disk and to "
"start man:hastd[8]:"
msgstr "如果配置存在于两个节点上，就可以创建 HAST 池。在两个节点上运行这些命令，将初始元数据放到本地磁盘上并启动 man:hastd[8]:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2316
#, no-wrap
msgid ""
"# hastctl create test\n"
"# service hastd onestart\n"
msgstr ""
"# hastctl create test\n"
"# service hastd onestart\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2322
msgid ""
"It is _not_ possible to use GEOM providers with an existing file system or to convert an existing storage to a HAST-managed pool.  This procedure needs to store some "
"metadata on the provider and there will not be enough required space available on an existing provider."
msgstr ""
"不可能用现有的文件系统使用 GEOM 提供者，也不可能将现有的存储转换为 HAST 管理的池。这个程序需要在提供者上存储一些元数据，而在现有的提供者上将没有足够的所需空间可用。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2326
msgid ""
"A HAST node's `primary` or `secondary` role is selected by an administrator, or software like Heartbeat, using man:hastctl[8].  On the primary node, `hasta`, issue this "
"command:"
msgstr "一个 HAST 节点的主要或次要角色是由管理员或像 Heartbeat 这样的软件使用 man:hastctl[8] 选择的。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2330
#, no-wrap
msgid "# hastctl role primary test\n"
msgstr "# hastctl role primary test\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2333
msgid "Run this command on the secondary node, `hastb`:"
msgstr "在主节点 `hastb` 上发出这个命令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2337
#, no-wrap
msgid "# hastctl role secondary test\n"
msgstr "# hastctl role secondary test\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2340
msgid "Verify the result by running `hastctl` on each node:"
msgstr "通过在每个节点上运行 `hastctl` 来验证结果："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2344
#, no-wrap
msgid "# hastctl status test\n"
msgstr "# hastctl status test\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2350
msgid ""
"Check the `status` line in the output.  If it says `degraded`, something is wrong with the configuration file.  It should say `complete` on each node, meaning that the "
"synchronization between the nodes has started.  The synchronization completes when `hastctl status` reports 0 bytes of `dirty` extents."
msgstr ""
"检查输出中的 `status` 行。如果它显示 `degraded` ，说明配置文件出了问题。它应该在每个节点上显示 `complete` ，意味着节点之间的同步已经开始。当 `hastctl status` 报告说有 0 "
"字节的 `dirty` 范围时，同步就完成了。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2355
msgid ""
"The next step is to create a file system on the GEOM provider and mount it.  This must be done on the `primary` node.  Creating the file system can take a few minutes, "
"depending on the size of the hard drive.  This example creates a UFS file system on [.filename]#/dev/hast/test#:"
msgstr ""
"下一步是在 GEOM 提供者上创建一个文件系统并挂载它。这必须在主节点上完成。创建文件系统可能需要几分钟时间，这取决于硬盘的大小。这个例子在 [.filename]#/dev/hast/test# 上创建"
"了一个 UFS 文件系统:"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2361
#, no-wrap
msgid ""
"# newfs -U /dev/hast/test\n"
"# mkdir /hast/test\n"
"# mount /dev/hast/test /hast/test\n"
msgstr ""
"# newfs -U /dev/hast/test\n"
"# mkdir /hast/test\n"
"# mount /dev/hast/test /hast/test\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2365
msgid ""
"Once the HAST framework is configured properly, the final step is to make sure that HAST is started automatically during system boot.  Add this line to [.filename]#/etc/"
"rc.conf#:"
msgstr "如果 HAST 框架被正确配置，最后一步是确保 HAST 在系统启动时自动启动。添加这一行到 [.filename]#/etc/rc.conf# 即可："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2369
#, no-wrap
msgid "hastd_enable=\"YES\"\n"
msgstr "hastd_enable=\"YES\"\n"

#. type: Title ====
#: content/zh-cn/books/handbook/disks/_index.adoc:2371
#, no-wrap
msgid "Failover Configuration"
msgstr "故障转移配置"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2375
msgid ""
"The goal of this example is to build a robust storage system which is resistant to the failure of any given node.  If the primary node fails, the secondary node is there "
"to take over seamlessly, check and mount the file system, and continue to work without missing a single bit of data."
msgstr ""
"这个例子的目标是建立一个强大的存储系统，它可以抵御任何特定节点的故障。如果主节点发生故障，副节点就会被无缝地接管，检查和挂载文件系统，并继续工作，不会丢失任何一点数据。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2381
msgid ""
"To accomplish this task, the Common Address Redundancy Protocol (CARP) is used to provide for automatic failover at the IP layer.  CARP allows multiple hosts on the same "
"network segment to share an IP address.  Set up CARP on both nodes of the cluster according to the documentation available in crossref:advanced-networking[carp,“Common "
"Address Redundancy Protocol (CARP)”].  In this example, each node will have its own management IP address and a shared IP address of _172.16.0.254_.  The primary HAST "
"node of the cluster must be the primary CARP node."
msgstr ""
"为了完成这项任务，通用地址冗余协议（CARP）被用来在 IP 层提供自动故障转移。CARP 允许同一网段的多个主机共享一个IP地址。根据 crossref:advanced-networking[carp,通用地址冗余协"
"议（ CARP ）] 中提供的文档，在集群的两个节点上设置 CARP 。在这个例子中，每个节点将有自己的管理 IP 地址和 _172.16.0.254_ 的共享 IP 地址。集群的主要 HAST 节点必须是主要的 "
"CARP 节点。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2385
msgid ""
"The HAST pool created in the previous section is now ready to be exported to the other hosts on the network.  This can be accomplished by exporting it through NFS or "
"Samba, using the shared IP address _172.16.0.254_.  The only problem which remains unresolved is an automatic failover should the primary node fail."
msgstr ""
"在上一节中创建的 HAST 池现在已经准备好被导出到网络上的其他主机。这可以通过 NFS 或 Samba 导出，使用共享 IP 地址 _172.16.0.254_ 来完成。唯一没有解决的问题是在主节点发生故障"
"时的自动故障转移。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2389
msgid ""
"In the event of CARP interfaces going up or down, the FreeBSD operating system generates a man:devd[8] event, making it possible to watch for state changes on the CARP "
"interfaces.  A state change on the CARP interface is an indication that one of the nodes failed or came back online.  These state change events make it possible to run a "
"script which will automatically handle the HAST failover."
msgstr ""
"在 CARP 接口开启或关闭时，FreeBSD 操作系统会生成 man:devd[8] 事件，从而可以观察 CARP 接口的状态变化。CARP 接口上的状态变化表明其中一个节点失败或重新上线了。这些状态变化事件"
"使运行一个脚本成为可能，该脚本将自动处理 HAST 故障切换。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2391
msgid "To catch state changes on the CARP interfaces, add this configuration to [.filename]#/etc/devd.conf# on each node:"
msgstr "为了捕捉 CARP 接口上的状态变化，在每个节点上的 [.filename]#/etc/devd.conf# 中添加这个配置："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2400
#, no-wrap
msgid ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_UP\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
"};\n"
msgstr ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_UP\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
"};\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2407
#, no-wrap
msgid ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_DOWN\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
"};\n"
msgstr ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_DOWN\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
"};\n"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2412
msgid "If the systems are running FreeBSD 10 or higher, replace [.filename]#carp0# with the name of the CARP-configured interface."
msgstr "如果系统运行的是 FreeBSD 10 或更高版本，用 CARP 配置的接口名称替换 [.filename]#carp0#。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2415
msgid "Restart man:devd[8] on both nodes to put the new configuration into effect:"
msgstr "在两个节点上重新启动 man:devd[8] 以使新配置生效。"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2419
#, no-wrap
msgid "# service devd restart\n"
msgstr "# service devd restart\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2423
msgid ""
"When the specified interface state changes by going up or down , the system generates a notification, allowing the man:devd[8] subsystem to run the specified automatic "
"failover script, [.filename]#/usr/local/sbin/carp-hast-switch#.  For further clarification about this configuration, refer to man:devd.conf[5]."
msgstr ""
"当指定的接口状态因开启或关闭而改变时，系统会产生一个通知，允许 man:devd[8] 子系统运行指定的自动故障切换脚本，[.filename]#/usr/local/sbin/carp-hast-switch# 。关于这个配置"
"的进一步说明，请参考 man:devd.conf[5]。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2425
msgid "Here is an example of an automated failover script:"
msgstr "下面是一个自动故障转移脚本的例子："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2429
#, no-wrap
msgid "#!/bin/sh\n"
msgstr "#!/bin/sh\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2433
#, no-wrap
msgid ""
"# Original script by Freddie Cash <fjwcash@gmail.com>\n"
"# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>\n"
"# and Viktor Petersson <vpetersson@wireload.net>\n"
msgstr ""
"# Original script by Freddie Cash <fjwcash@gmail.com>\n"
"# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>\n"
"# and Viktor Petersson <vpetersson@wireload.net>\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2436
#, no-wrap
msgid ""
"# The names of the HAST resources, as listed in /etc/hast.conf\n"
"resources=\"test\"\n"
msgstr ""
"# The names of the HAST resources, as listed in /etc/hast.conf\n"
"resources=\"test\"\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2440
#, no-wrap
msgid ""
"# delay in mounting HAST resource after becoming primary\n"
"# make your best guess\n"
"delay=3\n"
msgstr ""
"# delay in mounting HAST resource after becoming primary\n"
"# make your best guess\n"
"delay=3\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2444
#, no-wrap
msgid ""
"# logging\n"
"log=\"local0.debug\"\n"
"name=\"carp-hast\"\n"
msgstr ""
"# logging\n"
"log=\"local0.debug\"\n"
"name=\"carp-hast\"\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2446
#, no-wrap
msgid "# end of user configurable stuff\n"
msgstr "# end of user configurable stuff\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2451
#, no-wrap
msgid ""
"case \"$1\" in\n"
"\tprimary)\n"
"\t\tlogger -p $log -t $name \"Switching to primary provider for ${resources}.\"\n"
"\t\tsleep ${delay}\n"
msgstr ""
"case \"$1\" in\n"
"\tprimary)\n"
"\t\tlogger -p $log -t $name \"Switching to primary provider for ${resources}.\"\n"
"\t\tsleep ${delay}\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2457
#, no-wrap
msgid ""
"\t\t# Wait for any \"hastd secondary\" processes to stop\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\twhile $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 ); do\n"
"\t\t\t\tsleep 1\n"
"\t\t\tdone\n"
msgstr ""
"\t\t# Wait for any \"hastd secondary\" processes to stop\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\twhile $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 ); do\n"
"\t\t\t\tsleep 1\n"
"\t\t\tdone\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2465
#, no-wrap
msgid ""
"\t\t\t# Switch role for each disk\n"
"\t\t\thastctl role primary ${disk}\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to change role to primary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"
msgstr ""
"\t\t\t# Switch role for each disk\n"
"\t\t\thastctl role primary ${disk}\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to change role to primary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2472
#, no-wrap
msgid ""
"\t\t# Wait for the /dev/hast/* devices to appear\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tfor I in $( jot 60 ); do\n"
"\t\t\t\t[ -c \"/dev/hast/${disk}\" ] && break\n"
"\t\t\t\tsleep 0.5\n"
"\t\t\tdone\n"
msgstr ""
"\t\t# Wait for the /dev/hast/* devices to appear\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tfor I in $( jot 60 ); do\n"
"\t\t\t\t[ -c \"/dev/hast/${disk}\" ] && break\n"
"\t\t\t\tsleep 0.5\n"
"\t\t\tdone\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2478
#, no-wrap
msgid ""
"\t\t\tif [ ! -c \"/dev/hast/${disk}\" ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not appear.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"
msgstr ""
"\t\t\tif [ ! -c \"/dev/hast/${disk}\" ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not appear.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2480
#, no-wrap
msgid "\t\tlogger -p $log -t $name \"Role for HAST resources ${resources} switched to primary.\"\n"
msgstr "\t\tlogger -p $log -t $name \"Role for HAST resources ${resources} switched to primary.\"\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2487
#, no-wrap
msgid ""
"\t\tlogger -p $log -t $name \"Mounting disks.\"\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tmkdir -p /hast/${disk}\n"
"\t\t\tfsck -p -y -t ufs /dev/hast/${disk}\n"
"\t\t\tmount /dev/hast/${disk} /hast/${disk}\n"
"\t\tdone\n"
msgstr ""
"\t\tlogger -p $log -t $name \"Mounting disks.\"\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tmkdir -p /hast/${disk}\n"
"\t\t\tfsck -p -y -t ufs /dev/hast/${disk}\n"
"\t\t\tmount /dev/hast/${disk} /hast/${disk}\n"
"\t\tdone\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2489
#, no-wrap
msgid "\t;;\n"
msgstr "\t;;\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2492
#, no-wrap
msgid ""
"\tsecondary)\n"
"\t\tlogger -p $log -t $name \"Switching to secondary provider for ${resources}.\"\n"
msgstr ""
"\tsecondary)\n"
"\t\tlogger -p $log -t $name \"Switching to secondary provider for ${resources}.\"\n"

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2510
#, no-wrap
msgid ""
"\t\t# Switch roles for the HAST resources\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tif ! mount | grep -q \"^/dev/hast/${disk} on \"\n"
"\t\t\tthen\n"
"\t\t\telse\n"
"\t\t\t\tumount -f /hast/${disk}\n"
"\t\t\tfi\n"
"\t\t\tsleep $delay\n"
"\t\t\thastctl role secondary ${disk} 2>&1\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to switch role to secondary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\t\tlogger -p $log -t $name \"Role switched to secondary for resource ${disk}.\"\n"
"\t\tdone\n"
"\t;;\n"
"esac\n"
msgstr ""
"\t\t# Switch roles for the HAST resources\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tif ! mount | grep -q \"^/dev/hast/${disk} on \"\n"
"\t\t\tthen\n"
"\t\t\telse\n"
"\t\t\t\tumount -f /hast/${disk}\n"
"\t\t\tfi\n"
"\t\t\tsleep $delay\n"
"\t\t\thastctl role secondary ${disk} 2>&1\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to switch role to secondary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\t\tlogger -p $log -t $name \"Role switched to secondary for resource ${disk}.\"\n"
"\t\tdone\n"
"\t;;\n"
"esac\n"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2513
msgid "In a nutshell, the script takes these actions when a node becomes primary:"
msgstr "简而言之，当一个节点成为主节点时，脚本会采取这些行动："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2515
msgid "Promotes the HAST pool to primary on the other node."
msgstr "将另一个节点上的 HAST 池提升为主池。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2516
msgid "Checks the file system under the HAST pool."
msgstr "检查 HAST 池下的文件系统。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2517
msgid "Mounts the pool."
msgstr "挂载该池。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2519
msgid "When a node becomes secondary:"
msgstr "当一个节点成为次级节点时："

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2521
msgid "Unmounts the HAST pool."
msgstr "解除 HAST 池的挂载。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2522
msgid "Degrades the HAST pool to secondary."
msgstr "将 HAST 池降级为次级。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2527
msgid ""
"This is just an example script which serves as a proof of concept.  It does not handle all the possible scenarios and can be extended or altered in any way, for example, "
"to start or stop required services."
msgstr "这只是一个作为概念证明的脚本例子。它并不能处理所有可能的情况，可以以任何方式进行扩展或改变，例如，启动或停止所需的服务。"

#. type: delimited block = 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2533
msgid "For this example, a standard UFS file system was used.  To reduce the time needed for recovery, a journal-enabled UFS or ZFS file system can be used instead."
msgstr "在这个例子中，使用了一个基础的 UFS 文件系统。为了减少恢复所需的时间，可以使用支持日志的 UFS 或 ZFS 文件系统来代替。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2536
msgid "More detailed information with additional examples can be found at http://wiki.FreeBSD.org/HAST[http://wiki.FreeBSD.org/HAST]."
msgstr "更详细的信息和更多的例子可以在以下网站找到：http://wiki.FreeBSD.org/HAST[http://wiki.FreeBSD.org/HAST]."

#. type: Title ===
#: content/zh-cn/books/handbook/disks/_index.adoc:2537
#, no-wrap
msgid "Troubleshooting"
msgstr "故障排除"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2542
msgid ""
"HAST should generally work without issues.  However, as with any other software product, there may be times when it does not work as supposed.  The sources of the "
"problems may be different, but the rule of thumb is to ensure that the time is synchronized between the nodes of the cluster."
msgstr ""
"HAST 的工作一般应该没有问题。然而，就像任何其他软件产品一样，可能有的时候它不能像预期的那样工作。问题的来源可能是不同的，但经验法则是确保集群的节点之间的时间是同步的。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2546
msgid ""
"When troubleshooting HAST, the debugging level of man:hastd[8] should be increased by starting `hastd` with `-d`.  This argument may be specified multiple times to "
"further increase the debugging level.  Consider also using `-F`, which starts `hastd` in the foreground."
msgstr "当排除 HAST 的故障时，hastd(8) 的调试级别应该通过 hastd -d 来增加。这个参数可以指定多次以进一步提高调试级别。也可以考虑使用 -F，它在前台启动 hastd。"

#. type: Title ====
#: content/zh-cn/books/handbook/disks/_index.adoc:2548
#, no-wrap
msgid "Recovering from the Split-brain Condition"
msgstr "从“大脑分裂”中恢复过来"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2553
msgid ""
"_Split-brain_ occurs when the nodes of the cluster are unable to communicate with each other, and both are configured as primary.  This is a dangerous condition because "
"it allows both nodes to make incompatible changes to the data.  This problem must be corrected manually by the system administrator."
msgstr ""
"当集群的节点无法相互通信，而两个节点都被配置为主节点时，就会出现分脑。这是一个危险的情况，因为它允许两个节点对数据进行不兼容的修改。这个问题必须由系统管理员手动纠正。"

#. type: Plain text
#: content/zh-cn/books/handbook/disks/_index.adoc:2557
msgid ""
"The administrator must either decide which node has more important changes, or perform the merge manually.  Then, let HAST perform full synchronization of the node which "
"has the broken data.  To do this, issue these commands on the node which needs to be resynchronized:"
msgstr "管理员必须决定哪个节点有更重要的变化，或者手动执行合并。然后，让 HAST 对有破损数据的节点执行完全同步。要做到这一点，在需要重新同步的节点上发出这些命令："

#. type: delimited block . 4
#: content/zh-cn/books/handbook/disks/_index.adoc:2563
#, no-wrap
msgid ""
"# hastctl role init test\n"
"# hastctl create test\n"
"# hastctl role secondary test\n"
msgstr ""
"# hastctl role init test\n"
"# hastctl create test\n"
"# hastctl role secondary test\n"
